/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, shareReplay, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
var NGXMapperService = /** @class */ (function () {
    function NGXMapperService(httpBackend) {
        this.httpBackend = httpBackend;
        // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'
        this.sourceMapCache = new Map();
        // cache for specific log position, key is the dist position, ie 'main.js:339:21'
        this.logPositionCache = new Map();
    }
    /*
    Static Functions
   */
    /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    NGXMapperService.getStackLine = /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                return error.stack.split('\n')[5];
            }
            catch (e) {
                return null;
            }
        }
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getPosition = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        var positionStartIndex = stackLine.lastIndexOf('\/');
        /** @type {?} */
        var positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        /** @type {?} */
        var position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        /** @type {?} */
        var dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getTranspileLocation = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        /** @type {?} */
        var locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf(' ');
        }
        /** @type {?} */
        var locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    };
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    NGXMapperService.getMapFilePath = /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    function (stackLine) {
        /** @type {?} */
        var file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        var mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    };
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    NGXMapperService.getMapping = /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    function (sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        var sourceFileIndex = 0;
        /** @type {?} */
        var // second field
        sourceCodeLine = 0;
        /** @type {?} */
        var // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        var lines = sourceMap.mappings.split(';');
        for (var lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            var generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            var columns = lines[lineIndex].split(',');
            for (var columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                var decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    };
    /**
     * does the http get request to get the source map
     * @param sourceMapLocation
     * @param distPosition
     */
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    NGXMapperService.prototype._getSourceMap = /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    function (sourceMapLocation, distPosition) {
        /** @type {?} */
        var req = new HttpRequest('GET', sourceMapLocation);
        /** @type {?} */
        var distPositionKey = distPosition.toString();
        // if the specific log position is already in cache return it
        if (this.logPositionCache.has(distPositionKey)) {
            return this.logPositionCache.get(distPositionKey);
        }
        // otherwise check if the source map is already cached for given source map location
        if (!this.sourceMapCache.has(sourceMapLocation)) {
            // obtain the source map if not cached
            this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e instanceof HttpResponse; })), map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            function (httpResponse) { return httpResponse.body; })), retry(3), shareReplay(1)));
        }
        // at this point the source map is cached, use it to get specific log position mapping
        /** @type {?} */
        var logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((/**
         * @param {?} sourceMap
         * @return {?}
         */
        function (sourceMap) {
            // map generated position to source position
            return NGXMapperService.getMapping(sourceMap, distPosition);
        })), catchError((/**
         * @return {?}
         */
        function () { return of(distPosition); })), shareReplay(1));
        // store specific log position in cache for given dest position and return it
        this.logPositionCache.set(distPositionKey, logPosition$);
        return logPosition$;
    };
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param sourceMapsEnabled
     */
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    NGXMapperService.prototype.getCallerDetails = /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    function (sourceMapsEnabled) {
        // parse generated file mapping from stack trace
        var _this = this;
        // parse generated file mapping from stack trace
        /** @type {?} */
        var stackLine = NGXMapperService.getStackLine();
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = tslib_1.__read(_a, 2), distPosition = _b[0], sourceMapLocation = _b[1];
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return _this._getSourceMap(sourceMapLocation, distPosition);
        })));
    };
    NGXMapperService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NGXMapperService.ctorParameters = function () { return [
        { type: HttpBackend }
    ]; };
    return NGXMapperService;
}());
export { NGXMapperService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.sourceMapCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.logPositionCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.httpBackend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUN6QyxPQUFPLEVBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RSxPQUFPLEtBQUssR0FBRyxNQUFNLEtBQUssQ0FBQztBQUMzQixPQUFPLEVBQWEsRUFBRSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxVQUFVLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3RGLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUVqRDtJQVNFLDBCQUFvQixXQUF3QjtRQUF4QixnQkFBVyxHQUFYLFdBQVcsQ0FBYTs7UUFMcEMsbUJBQWMsR0FBdUMsSUFBSSxHQUFHLEVBQUUsQ0FBQzs7UUFHL0QscUJBQWdCLEdBQXlDLElBQUksR0FBRyxFQUFFLENBQUM7SUFHM0UsQ0FBQztJQUVEOztLQUVDOzs7Ozs7OztJQUNjLDZCQUFZOzs7Ozs7O0lBQTNCOztZQUNRLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRTtRQUV6QixJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU0sS0FBSyxDQUFDO1NBQ2I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUVWLElBQUk7Z0JBQ0YsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNuQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sSUFBSSxDQUFDO2FBQ2I7U0FDRjtJQUNILENBQUM7Ozs7OztJQUVjLDRCQUFXOzs7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WSxFQUFFO1FBRWpELGdGQUFnRjtRQUNoRixJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2QsT0FBTyxFQUFFLENBQUMsSUFBSSxXQUFXLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RDO1FBRUQsT0FBTyxFQUFFLENBQUM7WUFDUixnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDO1lBQ3ZDLGdCQUFnQixDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUM7U0FDM0MsQ0FBQyxDQUFDLElBQUksQ0FDTCxTQUFTOzs7O1FBQWlELFVBQUMsRUFBaUM7Z0JBQWpDLDBCQUFpQyxFQUFoQyxvQkFBWSxFQUFFLHlCQUFpQjtZQUV6Rix3R0FBd0c7WUFDeEcsNkRBQTZEO1lBQzdELElBQUksQ0FBQyxpQkFBaUIsRUFBRTtnQkFDdEIsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUM7YUFDekI7WUFFRCw0REFBNEQ7WUFDNUQsT0FBTyxLQUFJLENBQUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQzdELENBQUMsRUFBQyxDQUNILENBQUM7SUFHSixDQUFDOztnQkE3TEYsVUFBVTs7OztnQkFOSCxXQUFXOztJQW9NbkIsdUJBQUM7Q0FBQSxBQTlMRCxJQThMQztTQTdMWSxnQkFBZ0I7Ozs7OztJQUczQiwwQ0FBdUU7Ozs7O0lBR3ZFLDRDQUEyRTs7Ozs7SUFFL0QsdUNBQWdDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtTb3VyY2VNYXB9IGZyb20gJ0Bhbmd1bGFyL2NvbXBpbGVyJztcbmltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge0h0dHBCYWNrZW5kLCBIdHRwUmVxdWVzdCwgSHR0cFJlc3BvbnNlfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgKiBhcyB2bHEgZnJvbSAndmxxJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgb2Z9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtjYXRjaEVycm9yLCBmaWx0ZXIsIG1hcCwgcmV0cnksIHNoYXJlUmVwbGF5LCBzd2l0Y2hNYXB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7TG9nUG9zaXRpb259IGZyb20gJy4vdHlwZXMvbG9nLXBvc2l0aW9uJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5HWE1hcHBlclNlcnZpY2Uge1xuXG4gIC8vIGNhY2hlIGZvciBzb3VyY2UgbWFwcywga2V5IGlzIHNvdXJjZSBtYXAgbG9jYXRpb24sIGllLiAnaHR0cDovL2xvY2FsaG9zdDo0MjAwL21haW4uanMubWFwJ1xuICBwcml2YXRlIHNvdXJjZU1hcENhY2hlOiBNYXA8c3RyaW5nLCBPYnNlcnZhYmxlPFNvdXJjZU1hcD4+ID0gbmV3IE1hcCgpO1xuXG4gIC8vIGNhY2hlIGZvciBzcGVjaWZpYyBsb2cgcG9zaXRpb24sIGtleSBpcyB0aGUgZGlzdCBwb3NpdGlvbiwgaWUgJ21haW4uanM6MzM5OjIxJ1xuICBwcml2YXRlIGxvZ1Bvc2l0aW9uQ2FjaGU6IE1hcDxzdHJpbmcsIE9ic2VydmFibGU8TG9nUG9zaXRpb24+PiA9IG5ldyBNYXAoKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGh0dHBCYWNrZW5kOiBIdHRwQmFja2VuZCkge1xuICB9XG5cbiAgLypcbiAgU3RhdGljIEZ1bmN0aW9uc1xuICovXG4gIHByaXZhdGUgc3RhdGljIGdldFN0YWNrTGluZSgpOiBzdHJpbmcge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gbm9pbnNwZWN0aW9uIEV4Y2VwdGlvbkNhdWdodExvY2FsbHlKU1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSBjYXRjaCAoZSkge1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpWzVdO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRQb3NpdGlvbihzdGFja0xpbmU6IHN0cmluZyk6IExvZ1Bvc2l0aW9uIHtcbiAgICAvLyBzdHJpcCBiYXNlIHBhdGgsIHRoZW4gcGFyc2UgZmlsZW5hbWUsIGxpbmUsIGFuZCBjb2x1bW5cbiAgICBjb25zdCBwb3NpdGlvblN0YXJ0SW5kZXggPSBzdGFja0xpbmUubGFzdEluZGV4T2YoJ1xcLycpO1xuICAgIGxldCBwb3NpdGlvbkVuZEluZGV4ID0gc3RhY2tMaW5lLmluZGV4T2YoJyknKTtcbiAgICBpZiAocG9zaXRpb25FbmRJbmRleCA8IDApIHtcbiAgICAgIHBvc2l0aW9uRW5kSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgcG9zaXRpb24gPSBzdGFja0xpbmUuc3Vic3RyaW5nKHBvc2l0aW9uU3RhcnRJbmRleCArIDEsIHBvc2l0aW9uRW5kSW5kZXgpO1xuICAgIGNvbnN0IGRhdGFBcnJheSA9IHBvc2l0aW9uLnNwbGl0KCc6Jyk7XG4gICAgaWYgKGRhdGFBcnJheS5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oZGF0YUFycmF5WzBdLCArZGF0YUFycmF5WzFdLCArZGF0YUFycmF5WzJdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbigndW5rbm93bicsIDAsIDApO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0VHJhbnNwaWxlTG9jYXRpb24oc3RhY2tMaW5lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCBsb2NhdGlvblN0YXJ0SW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignKCcpO1xuICAgIGlmIChsb2NhdGlvblN0YXJ0SW5kZXggPCAwKSB7XG4gICAgICBsb2NhdGlvblN0YXJ0SW5kZXggPSBzdGFja0xpbmUubGFzdEluZGV4T2YoJyAnKTtcbiAgICB9XG5cbiAgICBsZXQgbG9jYXRpb25FbmRJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCcpJyk7XG4gICAgaWYgKGxvY2F0aW9uRW5kSW5kZXggPCAwKSB7XG4gICAgICBsb2NhdGlvbkVuZEluZGV4ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFja0xpbmUuc3Vic3RyaW5nKGxvY2F0aW9uU3RhcnRJbmRleCArIDEsIGxvY2F0aW9uRW5kSW5kZXgpO1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0TWFwRmlsZVBhdGgoc3RhY2tMaW5lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZpbGUgPSBOR1hNYXBwZXJTZXJ2aWNlLmdldFRyYW5zcGlsZUxvY2F0aW9uKHN0YWNrTGluZSk7XG4gICAgY29uc3QgbWFwRnVsbFBhdGggPSBmaWxlLnN1YnN0cmluZygwLCBmaWxlLmxhc3RJbmRleE9mKCc6JykpO1xuICAgIHJldHVybiBtYXBGdWxsUGF0aC5zdWJzdHJpbmcoMCwgbWFwRnVsbFBhdGgubGFzdEluZGV4T2YoJzonKSkgKyAnLm1hcCc7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRNYXBwaW5nKHNvdXJjZU1hcDogU291cmNlTWFwLCBwb3NpdGlvbjogTG9nUG9zaXRpb24pOiBMb2dQb3NpdGlvbiB7XG4gICAgLy8gPT4gJzsnIGluZGljYXRlcyBlbmQgb2YgYSBsaW5lXG4gICAgLy8gPT4gJywnIHNlcGFyYXRlcyBtYXBwaW5ncyBpbiBhIGxpbmVcbiAgICAvLyBkZWNvZGVkIG1hcHBpbmcgPT4gWyBnZW5lcmF0ZWRDb2RlQ29sdW1uLCBzb3VyY2VGaWxlSW5kZXgsIHNvdXJjZUNvZGVMaW5lLCBzb3VyY2VDb2RlQ29sdW1uLCBuYW1lSW5kZXggXVxuICAgIGxldCBzb3VyY2VGaWxlSW5kZXggPSAwLCAgIC8vIHNlY29uZCBmaWVsZFxuICAgICAgc291cmNlQ29kZUxpbmUgPSAwLCAgICAvLyB0aGlyZCBmaWVsZFxuICAgICAgc291cmNlQ29kZUNvbHVtbiA9IDA7ICAvLyBmb3VydGggZmllbGRcblxuICAgIGNvbnN0IGxpbmVzID0gc291cmNlTWFwLm1hcHBpbmdzLnNwbGl0KCc7Jyk7XG5cbiAgICBmb3IgKGxldCBsaW5lSW5kZXggPSAwOyBsaW5lSW5kZXggPCBsaW5lcy5sZW5ndGg7IGxpbmVJbmRleCsrKSB7XG4gICAgICAvLyByZXNldCBjb2x1bW4gcG9zaXRpb24gdG8gMCBhZnRlciBlYWNoIGxpbmVcbiAgICAgIGxldCBnZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcbiAgICAgIC8vIGRlY29kZSBzZWN0aW9ucyBpbiBsaW5lXG4gICAgICBjb25zdCBjb2x1bW5zID0gbGluZXNbbGluZUluZGV4XS5zcGxpdCgnLCcpO1xuXG4gICAgICBmb3IgKGxldCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1ucy5sZW5ndGg7IGNvbHVtbkluZGV4KyspIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZFNlY3Rpb24gPSB2bHEuZGVjb2RlKGNvbHVtbnNbY29sdW1uSW5kZXhdKTtcbiAgICAgICAgaWYgKGRlY29kZWRTZWN0aW9uLmxlbmd0aCA+PSA0KSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgICAgICAgIGdlbmVyYXRlZENvZGVDb2x1bW4gKz0gZGVjb2RlZFNlY3Rpb25bMF07XG4gICAgICAgICAgc291cmNlRmlsZUluZGV4ICs9IGRlY29kZWRTZWN0aW9uWzFdO1xuICAgICAgICAgIHNvdXJjZUNvZGVMaW5lICs9IGRlY29kZWRTZWN0aW9uWzJdO1xuICAgICAgICAgIHNvdXJjZUNvZGVDb2x1bW4gKz0gZGVjb2RlZFNlY3Rpb25bM107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBpZiBtYXRjaGluZyBtYXBcbiAgICAgICAgaWYgKGxpbmVJbmRleCA9PT0gcG9zaXRpb24ubGluZU51bWJlcikge1xuICAgICAgICAgIGlmIChnZW5lcmF0ZWRDb2RlQ29sdW1uID09PSBwb3NpdGlvbi5jb2x1bW5OdW1iZXIpIHtcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGNvbHVtbiBhbmQgbGluZSBmb3VuZFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihzb3VyY2VNYXAuc291cmNlc1tzb3VyY2VGaWxlSW5kZXhdLCBzb3VyY2VDb2RlTGluZSwgc291cmNlQ29kZUNvbHVtbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2x1bW5JbmRleCArIDEgPT09IGNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBtYXRjaGluZyBjb2x1bW4gbm90IGZvdW5kLCBidXQgbGluZSBpcyBjb3JyZWN0XG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKHNvdXJjZU1hcC5zb3VyY2VzW3NvdXJjZUZpbGVJbmRleF0sIHNvdXJjZUNvZGVMaW5lLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZmFpbGVkIGlmIHJlYWNoZWRcbiAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKCd1bmtub3duJywgMCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogZG9lcyB0aGUgaHR0cCBnZXQgcmVxdWVzdCB0byBnZXQgdGhlIHNvdXJjZSBtYXBcbiAgICogQHBhcmFtIHNvdXJjZU1hcExvY2F0aW9uXG4gICAqIEBwYXJhbSBkaXN0UG9zaXRpb25cbiAgICovXG4gIHByaXZhdGUgX2dldFNvdXJjZU1hcChzb3VyY2VNYXBMb2NhdGlvbjogc3RyaW5nLCBkaXN0UG9zaXRpb246IExvZ1Bvc2l0aW9uKTogT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4ge1xuICAgIGNvbnN0IHJlcSA9IG5ldyBIdHRwUmVxdWVzdDxTb3VyY2VNYXA+KCdHRVQnLCBzb3VyY2VNYXBMb2NhdGlvbik7XG4gICAgY29uc3QgZGlzdFBvc2l0aW9uS2V5ID0gZGlzdFBvc2l0aW9uLnRvU3RyaW5nKCk7XG5cbiAgICAvLyBpZiB0aGUgc3BlY2lmaWMgbG9nIHBvc2l0aW9uIGlzIGFscmVhZHkgaW4gY2FjaGUgcmV0dXJuIGl0XG4gICAgaWYgKHRoaXMubG9nUG9zaXRpb25DYWNoZS5oYXMoZGlzdFBvc2l0aW9uS2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMubG9nUG9zaXRpb25DYWNoZS5nZXQoZGlzdFBvc2l0aW9uS2V5KTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgY2hlY2sgaWYgdGhlIHNvdXJjZSBtYXAgaXMgYWxyZWFkeSBjYWNoZWQgZm9yIGdpdmVuIHNvdXJjZSBtYXAgbG9jYXRpb25cbiAgICBpZiAoIXRoaXMuc291cmNlTWFwQ2FjaGUuaGFzKHNvdXJjZU1hcExvY2F0aW9uKSkge1xuICAgICAgLy8gb2J0YWluIHRoZSBzb3VyY2UgbWFwIGlmIG5vdCBjYWNoZWRcbiAgICAgIHRoaXMuc291cmNlTWFwQ2FjaGUuc2V0KFxuICAgICAgICBzb3VyY2VNYXBMb2NhdGlvbixcbiAgICAgICAgdGhpcy5odHRwQmFja2VuZC5oYW5kbGUocmVxKS5waXBlKFxuICAgICAgICAgIGZpbHRlcigoZSkgPT4gZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSksXG4gICAgICAgICAgbWFwPEh0dHBSZXNwb25zZTxTb3VyY2VNYXA+LCBTb3VyY2VNYXA+KFxuICAgICAgICAgICAgKGh0dHBSZXNwb25zZTogSHR0cFJlc3BvbnNlPFNvdXJjZU1hcD4pID0+IGh0dHBSZXNwb25zZS5ib2R5XG4gICAgICAgICAgKSxcbiAgICAgICAgICByZXRyeSgzKSxcbiAgICAgICAgICBzaGFyZVJlcGxheSgxKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIHNvdXJjZSBtYXAgaXMgY2FjaGVkLCB1c2UgaXQgdG8gZ2V0IHNwZWNpZmljIGxvZyBwb3NpdGlvbiBtYXBwaW5nXG4gICAgY29uc3QgbG9nUG9zaXRpb24kID0gdGhpcy5zb3VyY2VNYXBDYWNoZS5nZXQoc291cmNlTWFwTG9jYXRpb24pLnBpcGUoXG4gICAgICBtYXA8U291cmNlTWFwLCBMb2dQb3NpdGlvbj4oKHNvdXJjZU1hcCkgPT5cbiAgICAgICAgLy8gbWFwIGdlbmVyYXRlZCBwb3NpdGlvbiB0byBzb3VyY2UgcG9zaXRpb25cbiAgICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRNYXBwaW5nKHNvdXJjZU1hcCwgZGlzdFBvc2l0aW9uKVxuICAgICAgKSxcbiAgICAgIGNhdGNoRXJyb3IoKCkgPT4gb2YoZGlzdFBvc2l0aW9uKSksXG4gICAgICBzaGFyZVJlcGxheSgxKVxuICAgICk7XG5cbiAgICAvLyBzdG9yZSBzcGVjaWZpYyBsb2cgcG9zaXRpb24gaW4gY2FjaGUgZm9yIGdpdmVuIGRlc3QgcG9zaXRpb24gYW5kIHJldHVybiBpdFxuICAgIHRoaXMubG9nUG9zaXRpb25DYWNoZS5zZXQoZGlzdFBvc2l0aW9uS2V5LCBsb2dQb3NpdGlvbiQpO1xuXG4gICAgcmV0dXJuIGxvZ1Bvc2l0aW9uJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBMb2dQb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgbG9nXG4gICAqIElmIHNvdXJjZU1hcHMgYXJlIGVuYWJsZWQsIGl0IGF0dGVtcHMgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwIGZyb20gdGhlIHNlcnZlciwgYW5kIHVzZSB0aGF0IHRvIHBhcnNlIHRoZSBmaWxlIG5hbWVcbiAgICogYW5kIG51bWJlciBvZiB0aGUgY2FsbFxuICAgKiBAcGFyYW0gc291cmNlTWFwc0VuYWJsZWRcbiAgICovXG4gIHB1YmxpYyBnZXRDYWxsZXJEZXRhaWxzKHNvdXJjZU1hcHNFbmFibGVkOiBib29sZWFuKTogT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4ge1xuICAgIC8vIHBhcnNlIGdlbmVyYXRlZCBmaWxlIG1hcHBpbmcgZnJvbSBzdGFjayB0cmFjZVxuXG4gICAgY29uc3Qgc3RhY2tMaW5lID0gTkdYTWFwcGVyU2VydmljZS5nZXRTdGFja0xpbmUoKTtcblxuICAgIC8vIGlmIHdlIHdlcmUgbm90IGFibGUgdG8gcGFyc2UgdGhlIHN0YWNrTGluZSwganVzdCByZXR1cm4gYW4gZW1wdHkgTG9nIFBvc2l0aW9uXG4gICAgaWYgKCFzdGFja0xpbmUpIHtcbiAgICAgIHJldHVybiBvZihuZXcgTG9nUG9zaXRpb24oJycsIDAsIDApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2YoW1xuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRQb3NpdGlvbihzdGFja0xpbmUpLFxuICAgICAgTkdYTWFwcGVyU2VydmljZS5nZXRNYXBGaWxlUGF0aChzdGFja0xpbmUpXG4gICAgXSkucGlwZShcbiAgICAgIHN3aXRjaE1hcDxbTG9nUG9zaXRpb24sIHN0cmluZ10sIE9ic2VydmFibGU8TG9nUG9zaXRpb24+PigoW2Rpc3RQb3NpdGlvbiwgc291cmNlTWFwTG9jYXRpb25dKSA9PiB7XG5cbiAgICAgICAgLy8gaWYgc291cmNlIG1hcHMgYXJlIG5vdCBlbmFibGVkLCBvciBpZiB3ZSd2ZSBwcmV2aW91c2x5IHRyaWVkIHRvIGdldCB0aGUgc291cmNlIG1hcHMsIGJ1dCB0aGV5IGZhaWxlZCxcbiAgICAgICAgLy8gdGhlbiBqdXN0IHVzZSB0aGUgcG9zaXRpb24gb2YgdGhlIEpTIGluc3RlYWQgb2YgdGhlIHNvdXJjZVxuICAgICAgICBpZiAoIXNvdXJjZU1hcHNFbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9mKGRpc3RQb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaW5hbGx5IHRyeSB0byBnZXQgdGhlIHNvdXJjZSBtYXAgYW5kIHJldHVybiB0aGUgcG9zaXRpb25cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNvdXJjZU1hcChzb3VyY2VNYXBMb2NhdGlvbiwgZGlzdFBvc2l0aW9uKTtcbiAgICAgIH0pXG4gICAgKTtcblxuXG4gIH1cbn1cblxuXG5cblxuIl19
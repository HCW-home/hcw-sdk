{"version":3,"file":"hug-angular-lib.js","sources":["ng://hug-angular-lib/lib/room2.service.ts","ng://hug-angular-lib/lib/hug-angular-lib.service.ts","ng://hug-angular-lib/lib/hug-angular-lib.component.ts","ng://hug-angular-lib/lib/log.service.ts","ng://hug-angular-lib/lib/hug-angular-lib.module.ts","ng://hug-angular-lib/lib/room.service.ts","ng://hug-angular-lib/public-api.ts","ng://hug-angular-lib/hug-angular-lib.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class Room2Service {\n  room = 2\n  constructor() { }\n}\n","import { Room2Service } from './room2.service';\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class HugAngularLibService {\n\n  public random:number\n  public random2:number\n  constructor(private room2: Room2Service) {\n    this.random = Math.random()\n  }\n}\n","import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'lib-hug-angular-lib',\n  template: `\n    <p>\n      hug-fuck shit address\n    </p>\n  `,\n  styles: []\n})\nexport class HugAngularLibComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n\n  }\n\n}\n","// import { Injectable } from '@angular/core';\nexport { NGXLogger as LogService } from 'ngx-logger';\n\n// @Injectable({\n//   providedIn: 'root'\n// })\n// export class LogService extends NGXLogger {\n\n//   constructor() {\n//     super()\n//   }\n// }\n","import { LogService } from './log.service';\nimport { NgModule } from '@angular/core';\nimport { HugAngularLibComponent } from './hug-angular-lib.component';\nimport { LoggerModule, NgxLoggerLevel } from 'ngx-logger';\n\nconsole.log('NGX logger')\n@NgModule({\n  declarations: [HugAngularLibComponent],\n  imports: [\n    LoggerModule.forRoot({serverLoggingUrl: '/api/logs', level: NgxLoggerLevel.DEBUG, serverLogLevel: NgxLoggerLevel.ERROR})\n  ],\n  providers:[LogService],\n  exports: [HugAngularLibComponent]\n})\nexport class HugAngularLibModule { }\n","import { Room2Service } from './room2.service';\nimport { Injectable } from '@angular/core';\n\n\n\n\nlet saveAs;\n\nlet mediasoupClient;\n\n\nlet requestTimeout,\n\tlastN,\n\tmobileLastN,\n\tvideoAspectRatio;\n\n\n\t// {\n\t// \trequestTimeout = 20000,\n\t// \tlastN = 4,\n\t// \tmobileLastN = 1,\n\t// \tvideoAspectRatio = 1.777 // 16 : 9\n\t// }\n\n\n\nconst VIDEO_CONSTRAINS =\n{\n\t'low' :\n\t{\n\t\twidth       : { ideal: 320 },\n\t\taspectRatio : videoAspectRatio\n\t},\n\t'medium' :\n\t{\n\t\twidth       : { ideal: 640 },\n\t\taspectRatio : videoAspectRatio\n\t},\n\t'high' :\n\t{\n\t\twidth       : { ideal: 1280 },\n\t\taspectRatio : videoAspectRatio\n\t},\n\t'veryhigh' :\n\t{\n\t\twidth       : { ideal: 1920 },\n\t\taspectRatio : videoAspectRatio\n\t},\n\t'ultra' :\n\t{\n\t\twidth       : { ideal: 3840 },\n\t\taspectRatio : videoAspectRatio\n\t}\n};\n\nconst PC_PROPRIETARY_CONSTRAINTS =\n{\n\toptional : [ { googDscp: true } ]\n};\n\nconst VIDEO_SIMULCAST_ENCODINGS =\n[\n\t{ scaleResolutionDownBy: 4, maxBitRate: 100000 },\n\t{ scaleResolutionDownBy: 1, maxBitRate: 1200000 }\n];\n\n// Used for VP9 webcam video.\nconst VIDEO_KSVC_ENCODINGS =\n[\n\t{ scalabilityMode: 'S3T3_KEY' }\n];\n\n// Used for VP9 desktop sharing.\nconst VIDEO_SVC_ENCODINGS =\n[\n\t{ scalabilityMode: 'S3T3', dtx: true }\n];\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport  class RoomService {\n\n\n\n  // Transport for sending.\n  _sendTransport = null;\n  // Transport for receiving.\n  _recvTransport = null;\n\n  _closed = false;\n\n  _produce = true;\n\n  _forceTcp = false;\n\n  _muted\n  _device\n  _peerId\n  _soundAlert\n  _roomId\n  _mediasoupDevice\n\n  _micProducer\n  _hark\n  _harkStream\n  _webcamProducer\n  _extraVideoProducers\n  _webcams\n  _audioDevices\n  _audioOutputDevices\n  _consumers\n\n\n  constructor() {\n\n\n  }\n\n  init({\n    peerId=null,\n    device= null,\n    produce=true,\n    forceTcp=false,\n    muted=true\n  } = {}) {\n    if (!peerId)\n      throw new Error('Missing peerId');\n    else if (!device)\n      throw new Error('Missing device');\n\n    // logger.debug(\n    //   'constructor() [peerId: \"%s\", device: \"%s\", produce: \"%s\", forceTcp: \"%s\", displayName \"\"]',\n    //   peerId, device.flag, produce, forceTcp);\n\n\n\n\n    // Whether we should produce.\n    this._produce = produce;\n\n    // Whether we force TCP\n    this._forceTcp = forceTcp;\n\n\n\n\n    // Whether simulcast should be used.\n    // this._useSimulcast = false;\n\n    // if ('simulcast' in window.config)\n    //   this._useSimulcast = window.config.simulcast;\n\n\n\n\n\n    this._muted = muted;\n\n    // This device\n    this._device = device;\n\n    // My peer name.\n    this._peerId = peerId;\n\n\n\n    // Alert sound\n    this._soundAlert = new Audio('/sounds/notify.mp3');\n\n\n\n\n    // The room ID\n    this._roomId = null;\n\n    // mediasoup-client Device instance.\n    // @type {mediasoupClient.Device}\n    this._mediasoupDevice = null;\n\n\n    // Transport for sending.\n    this._sendTransport = null;\n\n    // Transport for receiving.\n    this._recvTransport = null;\n\n    // Local mic mediasoup Producer.\n    this._micProducer = null;\n\n    // Local mic hark\n    this._hark = null;\n\n    // Local MediaStream for hark\n    this._harkStream = null;\n\n    // Local webcam mediasoup Producer.\n    this._webcamProducer = null;\n\n    // Extra videos being produced\n    this._extraVideoProducers = new Map();\n\n    // Map of webcam MediaDeviceInfos indexed by deviceId.\n    // @type {Map<String, MediaDeviceInfos>}\n    this._webcams = {};\n\n    this._audioDevices = {};\n\n    this._audioOutputDevices = {};\n\n    // mediasoup Consumers.\n    // @type {Map<String, mediasoupClient.Consumer>}\n    this._consumers = new Map();\n\n\n    // this._startKeyListener();\n\n    // this._startDevicesListener();\n\n  }\n  // close() {\n  //   if (this._closed)\n  //     return;\n\n  //   this._closed = true;\n\n  //   logger.debug('close()');\n\n  //   this._signalingSocket.close();\n\n  //   // Close mediasoup Transports.\n  //   if (this._sendTransport)\n  //     this._sendTransport.close();\n\n  //   if (this._recvTransport)\n  //     this._recvTransport.close();\n\n  //   store.dispatch(roomActions.setRoomState('closed'));\n\n  //   window.location = `/${this._roomId}`;\n  // }\n\n  // _startKeyListener() {\n  //   // Add keydown event listener on document\n  //   document.addEventListener('keydown', (event) => {\n  //     if (event.repeat) return;\n  //     const key = String.fromCharCode(event.which);\n\n  //     const source = event.target;\n\n  //     const exclude = ['input', 'textarea'];\n\n  //     if (exclude.indexOf(source.tagName.toLowerCase()) === -1) {\n  //       logger.debug('keyDown() [key:\"%s\"]', key);\n\n  //       switch (key) {\n\n  //         /*\n  //         case String.fromCharCode(37):\n  //         {\n  //           const newPeerId = this._spotlights.getPrevAsSelected(\n  //             store.getState().room.selectedPeerId);\n\n  //           if (newPeerId) this.setSelectedPeer(newPeerId);\n  //           break;\n  //         }\n\n  //         case String.fromCharCode(39):\n  //         {\n  //           const newPeerId = this._spotlights.getNextAsSelected(\n  //             store.getState().room.selectedPeerId);\n\n  //           if (newPeerId) this.setSelectedPeer(newPeerId);\n  //           break;\n  //         }\n  //         */\n\n\n  //         case 'M': // Toggle microphone\n  //           {\n  //             if (this._micProducer) {\n  //               if (!this._micProducer.paused) {\n  //                 this.muteMic();\n\n  //                 store.dispatch(requestActions.notify(\n  //                   {\n  //                     text: intl.formatMessage({\n  //                       id: 'devices.microphoneMute',\n  //                       defaultMessage: 'Muted your microphone'\n  //                     })\n  //                   }));\n  //               }\n  //               else {\n  //                 this.unmuteMic();\n\n  //                 store.dispatch(requestActions.notify(\n  //                   {\n  //                     text: intl.formatMessage({\n  //                       id: 'devices.microphoneUnMute',\n  //                       defaultMessage: 'Unmuted your microphone'\n  //                     })\n  //                   }));\n  //               }\n  //             }\n  //             else {\n  //               this.updateMic({ start: true });\n\n  //               store.dispatch(requestActions.notify(\n  //                 {\n  //                   text: intl.formatMessage({\n  //                     id: 'devices.microphoneEnable',\n  //                     defaultMessage: 'Enabled your microphone'\n  //                   })\n  //                 }));\n  //             }\n\n  //             break;\n  //           }\n\n  //         case 'V': // Toggle video\n  //           {\n  //             if (this._webcamProducer)\n  //               this.disableWebcam();\n  //             else\n  //               this.updateWebcam({ start: true });\n\n  //             break;\n  //           }\n\n  //         case 'H': // Open help dialog\n  //           {\n  //             store.dispatch(roomActions.setHelpOpen(true));\n\n  //             break;\n  //           }\n\n  //         default:\n  //           {\n  //             break;\n  //           }\n  //       }\n  //     }\n  //   });\n\n\n  // }\n\n  // _startDevicesListener() {\n  //   navigator.mediaDevices.addEventListener('devicechange', async () => {\n  //     logger.debug('_startDevicesListener() | navigator.mediaDevices.ondevicechange');\n\n  //     await this._updateAudioDevices();\n  //     await this._updateWebcams();\n  //     await this._updateAudioOutputDevices();\n\n  //     store.dispatch(requestActions.notify(\n  //       {\n  //         text: intl.formatMessage({\n  //           id: 'devices.devicesChanged',\n  //           defaultMessage: 'Your devices changed, configure your devices in the settings dialog'\n  //         })\n  //       }));\n  //   });\n  // }\n\n\n  // _soundNotification() {\n  //   const { notificationSounds } = store.getState().settings;\n\n  //   if (notificationSounds) {\n  //     const alertPromise = this._soundAlert.play();\n\n  //     if (alertPromise !== undefined) {\n  //       alertPromise\n  //         .then()\n  //         .catch((error) => {\n  //           logger.error('_soundAlert.play() [error:\"%o\"]', error);\n  //         });\n  //     }\n  //   }\n  // }\n\n  // timeoutCallback(callback) {\n  //   let called = false;\n\n  //   const interval = setTimeout(\n  //     () => {\n  //       if (called)\n  //         return;\n  //       called = true;\n  //       callback(new SocketTimeoutError('Request timed out'));\n  //     },\n  //     requestTimeout\n  //   );\n\n  //   return (...args) => {\n  //     if (called)\n  //       return;\n  //     called = true;\n  //     clearTimeout(interval);\n\n  //     callback(...args);\n  //   };\n  // }\n\n  // _sendRequest(method, data) {\n  //   return new Promise((resolve, reject) => {\n  //     if (!this._signalingSocket) {\n  //       reject('No socket connection');\n  //     }\n  //     else {\n  //       this._signalingSocket.emit(\n  //         'request',\n  //         { method, data },\n  //         this.timeoutCallback((err, response) => {\n  //           if (err)\n  //             reject(err);\n  //           else\n  //             resolve(response);\n  //         })\n  //       );\n  //     }\n  //   });\n  // }\n\n  // async getTransportStats() {\n  //   try {\n  //     if (this._recvTransport) {\n  //       logger.debug('getTransportStats() - recv [transportId: \"%s\"]', this._recvTransport.id);\n\n  //       const recv = await this.sendRequest('getTransportStats', { transportId: this._recvTransport.id });\n\n  //       store.dispatch(\n  //         transportActions.addTransportStats(recv, 'recv'));\n  //     }\n\n  //     if (this._sendTransport) {\n  //       logger.debug('getTransportStats() - send [transportId: \"%s\"]', this._sendTransport.id);\n\n  //       const send = await this.sendRequest('getTransportStats', { transportId: this._sendTransport.id });\n\n  //       store.dispatch(\n  //         transportActions.addTransportStats(send, 'send'));\n  //     }\n  //   }\n  //   catch (error) {\n  //     logger.error('getTransportStats() [error:\"%o\"]', error);\n  //   }\n  // }\n\n  // async sendRequest(method, data) {\n  //   logger.debug('sendRequest() [method:\"%s\", data:\"%o\"]', method, data);\n\n  //   const {\n  //     requestRetries = 3\n  //   } = window.config;\n\n  //   for (let tries = 0; tries < requestRetries; tries++) {\n  //     try {\n  //       return await this._sendRequest(method, data);\n  //     }\n  //     catch (error) {\n  //       if (\n  //         error instanceof SocketTimeoutError &&\n  //         tries < requestRetries\n  //       )\n  //         logger.warn('sendRequest() | timeout, retrying [attempt:\"%s\"]', tries);\n  //       else\n  //         throw error;\n  //     }\n  //   }\n  // }\n\n\n\n\n  // async muteMic() {\n  //   logger.debug('muteMic()');\n\n  //   this._micProducer.pause();\n\n  //   try {\n  //     await this.sendRequest(\n  //       'pauseProducer', { producerId: this._micProducer.id });\n\n  //     store.dispatch(\n  //       producerActions.setProducerPaused(this._micProducer.id));\n\n  //     store.dispatch(\n  //       settingsActions.setAudioMuted(true));\n\n  //   }\n  //   catch (error) {\n  //     logger.error('muteMic() [error:\"%o\"]', error);\n\n  //     store.dispatch(requestActions.notify(\n  //       {\n  //         type: 'error',\n  //         text: intl.formatMessage({\n  //           id: 'devices.microphoneMuteError',\n  //           defaultMessage: 'Unable to mute your microphone'\n  //         })\n  //       }));\n  //   }\n  // }\n\n  // async unmuteMic() {\n  //   logger.debug('unmuteMic()');\n\n  //   if (!this._micProducer) {\n  //     this.updateMic({ start: true });\n  //   }\n  //   else {\n  //     this._micProducer.resume();\n\n  //     try {\n  //       await this.sendRequest(\n  //         'resumeProducer', { producerId: this._micProducer.id });\n\n  //       store.dispatch(\n  //         producerActions.setProducerResumed(this._micProducer.id));\n\n  //       store.dispatch(\n  //         settingsActions.setAudioMuted(false));\n\n  //     }\n  //     catch (error) {\n  //       logger.error('unmuteMic() [error:\"%o\"]', error);\n\n  //       store.dispatch(requestActions.notify(\n  //         {\n  //           type: 'error',\n  //           text: intl.formatMessage({\n  //             id: 'devices.microphoneUnMuteError',\n  //             defaultMessage: 'Unable to unmute your microphone'\n  //           })\n  //         }));\n  //     }\n  //   }\n  // }\n\n\n  // disconnectLocalHark() {\n  //   logger.debug('disconnectLocalHark()');\n\n  //   if (this._harkStream != null) {\n  //     let [track] = this._harkStream.getAudioTracks();\n\n  //     track.stop();\n  //     track = null;\n\n  //     this._harkStream = null;\n  //   }\n\n  //   if (this._hark != null)\n  //     this._hark.stop();\n  // }\n\n  // connectLocalHark(track) {\n  //   logger.debug('connectLocalHark() [track:\"%o\"]', track);\n\n  //   this._harkStream = new MediaStream();\n\n  //   const newTrack = track.clone();\n\n  //   this._harkStream.addTrack(newTrack);\n\n  //   newTrack.enabled = true;\n\n  //   this._hark = hark(this._harkStream,\n  //     {\n  //       play: false,\n  //       interval: 10,\n  //       threshold: store.getState().settings.noiseThreshold,\n  //       history: 100\n  //     });\n\n  //   this._hark.lastVolume = -100;\n\n  //   this._hark.on('volume_change', (volume) => {\n  //     // Update only if there is a bigger diff\n  //     if (this._micProducer && Math.abs(volume - this._hark.lastVolume) > 0.5) {\n  //       // Decay calculation: keep in mind that volume range is -100 ... 0 (dB)\n  //       // This makes decay volume fast if difference to last saved value is big\n  //       // and slow for small changes. This prevents flickering volume indicator\n  //       // at low levels\n  //       if (volume < this._hark.lastVolume) {\n  //         volume =\n  //           this._hark.lastVolume -\n  //           Math.pow(\n  //             (volume - this._hark.lastVolume) /\n  //             (100 + this._hark.lastVolume)\n  //             , 2\n  //           ) * 10;\n  //       }\n\n  //       this._hark.lastVolume = volume;\n\n  //       store.dispatch(peerVolumeActions.setPeerVolume(this._peerId, volume));\n  //     }\n  //   });\n\n  //   this._hark.on('speaking', () => {\n  //     store.dispatch(meActions.setIsSpeaking(true));\n\n  //     if (\n  //       (store.getState().settings.voiceActivatedUnmute ||\n  //         store.getState().me.isAutoMuted) &&\n  //       this._micProducer &&\n  //       this._micProducer.paused\n  //     )\n  //       this._micProducer.resume();\n\n  //     store.dispatch(meActions.setAutoMuted(false)); // sanity action\n  //   });\n\n  //   this._hark.on('stopped_speaking', () => {\n  //     store.dispatch(meActions.setIsSpeaking(false));\n\n  //     if (\n  //       store.getState().settings.voiceActivatedUnmute &&\n  //       this._micProducer &&\n  //       !this._micProducer.paused\n  //     ) {\n  //       this._micProducer.pause();\n\n  //       store.dispatch(meActions.setAutoMuted(true));\n  //     }\n  //   });\n  // }\n\n  // async changeAudioOutputDevice(deviceId) {\n  //   logger.debug('changeAudioOutputDevice() [deviceId:\"%s\"]', deviceId);\n\n  //   store.dispatch(\n  //     meActions.setAudioOutputInProgress(true));\n\n  //   try {\n  //     const device = this._audioOutputDevices[deviceId];\n\n  //     if (!device)\n  //       throw new Error('Selected audio output device no longer available');\n\n  //     store.dispatch(settingsActions.setSelectedAudioOutputDevice(deviceId));\n\n  //     await this._updateAudioOutputDevices();\n  //   }\n  //   catch (error) {\n  //     logger.error('changeAudioOutputDevice() [error:\"%o\"]', error);\n  //   }\n\n  //   store.dispatch(\n  //     meActions.setAudioOutputInProgress(false));\n  // }\n\n  // // Only Firefox supports applyConstraints to audio tracks\n  // // See:\n  // // https://bugs.chromium.org/p/chromium/issues/detail?id=796964\n  // async updateMic({\n  //   start = false,\n  //   restart = false || this._device.flag !== 'firefox',\n  //   newDeviceId = null\n  // } = {}) {\n  //   logger.debug(\n  //     'updateMic() [start:\"%s\", restart:\"%s\", newDeviceId:\"%s\"]',\n  //     start,\n  //     restart,\n  //     newDeviceId\n  //   );\n\n  //   let track;\n\n  //   try {\n  //     if (!this._mediasoupDevice.canProduce('audio'))\n  //       throw new Error('cannot produce audio');\n\n  //     if (newDeviceId && !restart)\n  //       throw new Error('changing device requires restart');\n\n  //     if (newDeviceId)\n  //       store.dispatch(settingsActions.setSelectedAudioDevice(newDeviceId));\n\n  //     store.dispatch(meActions.setAudioInProgress(true));\n\n  //     const deviceId = await this._getAudioDeviceId();\n  //     const device = this._audioDevices[deviceId];\n\n  //     if (!device)\n  //       throw new Error('no audio devices');\n\n  //     const {\n  //       autoGainControl,\n  //       echoCancellation,\n  //       noiseSuppression\n  //     } = store.getState().settings;\n\n  //     if (!window.config.centralAudioOptions) {\n  //       throw new Error(\n  //         'Missing centralAudioOptions from app config! (See it in example config.)'\n  //       );\n  //     }\n\n  //     const {\n  //       sampleRate = 96000,\n  //       channelCount = 1,\n  //       volume = 1.0,\n  //       sampleSize = 16,\n  //       opusStereo = false,\n  //       opusDtx = true,\n  //       opusFec = true,\n  //       opusPtime = 20,\n  //       opusMaxPlaybackRate = 96000\n  //     } = window.config.centralAudioOptions;\n\n  //     if (\n  //       (restart && this._micProducer) ||\n  //       start\n  //     ) {\n  //       this.disconnectLocalHark();\n\n  //       if (this._micProducer)\n  //         await this.disableMic();\n\n  //       const stream = await navigator.mediaDevices.getUserMedia(\n  //         {\n  //           audio: {\n  //             deviceId: { ideal: deviceId },\n  //             sampleRate,\n  //             channelCount,\n  //             volume,\n  //             autoGainControl,\n  //             echoCancellation,\n  //             noiseSuppression,\n  //             sampleSize\n  //           }\n  //         }\n  //       );\n\n  //       ([track] = stream.getAudioTracks());\n\n  //       const { deviceId: trackDeviceId } = track.getSettings();\n\n  //       store.dispatch(settingsActions.setSelectedAudioDevice(trackDeviceId));\n\n  //       this._micProducer = await this._sendTransport.produce(\n  //         {\n  //           track,\n  //           codecOptions:\n  //           {\n  //             opusStereo,\n  //             opusDtx,\n  //             opusFec,\n  //             opusPtime,\n  //             opusMaxPlaybackRate\n  //           },\n  //           appData:\n  //             { source: 'mic' }\n  //         });\n\n  //       store.dispatch(producerActions.addProducer(\n  //         {\n  //           id: this._micProducer.id,\n  //           source: 'mic',\n  //           paused: this._micProducer.paused,\n  //           track: this._micProducer.track,\n  //           rtpParameters: this._micProducer.rtpParameters,\n  //           codec: this._micProducer.rtpParameters.codecs[0].mimeType.split('/')[1]\n  //         }));\n\n  //       this._micProducer.on('transportclose', () => {\n  //         this._micProducer = null;\n  //       });\n\n  //       this._micProducer.on('trackended', () => {\n  //         store.dispatch(requestActions.notify(\n  //           {\n  //             type: 'error',\n  //             text: intl.formatMessage({\n  //               id: 'devices.microphoneDisconnected',\n  //               defaultMessage: 'Microphone disconnected'\n  //             })\n  //           }));\n\n  //         this.disableMic();\n  //       });\n\n  //       this._micProducer.volume = 0;\n\n  //       this.connectLocalHark(track);\n  //     }\n  //     else if (this._micProducer) {\n  //       ({ track } = this._micProducer);\n\n  //       await track.applyConstraints(\n  //         {\n  //           sampleRate,\n  //           channelCount,\n  //           volume,\n  //           autoGainControl,\n  //           echoCancellation,\n  //           noiseSuppression,\n  //           sampleSize\n  //         }\n  //       );\n\n  //       if (this._harkStream != null) {\n  //         const [harkTrack] = this._harkStream.getAudioTracks();\n\n  //         harkTrack && await harkTrack.applyConstraints(\n  //           {\n  //             sampleRate,\n  //             channelCount,\n  //             volume,\n  //             autoGainControl,\n  //             echoCancellation,\n  //             noiseSuppression,\n  //             sampleSize\n  //           }\n  //         );\n  //       }\n  //     }\n\n  //     await this._updateAudioDevices();\n  //   }\n  //   catch (error) {\n  //     logger.error('updateMic() [error:\"%o\"]', error);\n\n  //     store.dispatch(requestActions.notify(\n  //       {\n  //         type: 'error',\n  //         text: intl.formatMessage({\n  //           id: 'devices.microphoneError',\n  //           defaultMessage: 'An error occurred while accessing your microphone'\n  //         })\n  //       }));\n\n  //     if (track)\n  //       track.stop();\n  //   }\n\n  //   store.dispatch(meActions.setAudioInProgress(false));\n  // }\n\n  // async updateWebcam({\n  //   init = false,\n  //   start = false,\n  //   restart = false,\n  //   newDeviceId = null,\n  //   newResolution = null,\n  //   newFrameRate = null\n  // } = {}) {\n  //   logger.debug(\n  //     'updateWebcam() [start:\"%s\", restart:\"%s\", newDeviceId:\"%s\", newResolution:\"%s\", newFrameRate:\"%s\"]',\n  //     start,\n  //     restart,\n  //     newDeviceId,\n  //     newResolution,\n  //     newFrameRate\n  //   );\n\n  //   let track;\n\n  //   try {\n  //     if (!this._mediasoupDevice.canProduce('video'))\n  //       throw new Error('cannot produce video');\n\n  //     if (newDeviceId && !restart)\n  //       throw new Error('changing device requires restart');\n\n  //     if (newDeviceId)\n  //       store.dispatch(settingsActions.setSelectedWebcamDevice(newDeviceId));\n\n  //     if (newResolution)\n  //       store.dispatch(settingsActions.setVideoResolution(newResolution));\n\n  //     if (newFrameRate)\n  //       store.dispatch(settingsActions.setVideoFrameRate(newFrameRate));\n\n  //     const { videoMuted } = store.getState().settings;\n\n  //     if (init && videoMuted)\n  //       return;\n  //     else\n  //       store.dispatch(settingsActions.setVideoMuted(false));\n\n  //     store.dispatch(meActions.setWebcamInProgress(true));\n\n  //     const deviceId = await this._getWebcamDeviceId();\n  //     const device = this._webcams[deviceId];\n\n  //     if (!device)\n  //       throw new Error('no webcam devices');\n\n  //     const {\n  //       resolution,\n  //       frameRate\n  //     } = store.getState().settings;\n\n  //     if (\n  //       (restart && this._webcamProducer) ||\n  //       start\n  //     ) {\n  //       if (this._webcamProducer)\n  //         await this.disableWebcam();\n\n  //       const stream = await navigator.mediaDevices.getUserMedia(\n  //         {\n  //           video:\n  //           {\n  //             deviceId: { ideal: deviceId },\n  //             ...VIDEO_CONSTRAINS[resolution],\n  //             frameRate\n  //           }\n  //         });\n\n  //       ([track] = stream.getVideoTracks());\n\n  //       const { deviceId: trackDeviceId } = track.getSettings();\n\n  //       store.dispatch(settingsActions.setSelectedWebcamDevice(trackDeviceId));\n\n  //       if (this._useSimulcast) {\n  //         // If VP9 is the only available video codec then use SVC.\n  //         const firstVideoCodec = this._mediasoupDevice\n  //           .rtpCapabilities\n  //           .codecs\n  //           .find((c) => c.kind === 'video');\n\n  //         let encodings;\n\n  //         if (firstVideoCodec.mimeType.toLowerCase() === 'video/vp9')\n  //           encodings = VIDEO_KSVC_ENCODINGS;\n  //         else if ('simulcastEncodings' in window.config)\n  //           encodings = window.config.simulcastEncodings;\n  //         else\n  //           encodings = VIDEO_SIMULCAST_ENCODINGS;\n\n  //         this._webcamProducer = await this._sendTransport.produce(\n  //           {\n  //             track,\n  //             encodings,\n  //             codecOptions:\n  //             {\n  //               videoGoogleStartBitrate: 1000\n  //             },\n  //             appData:\n  //             {\n  //               source: 'webcam'\n  //             }\n  //           });\n  //       }\n  //       else {\n  //         this._webcamProducer = await this._sendTransport.produce({\n  //           track,\n  //           appData:\n  //           {\n  //             source: 'webcam'\n  //           }\n  //         });\n  //       }\n\n  //       store.dispatch(producerActions.addProducer(\n  //         {\n  //           id: this._webcamProducer.id,\n  //           source: 'webcam',\n  //           paused: this._webcamProducer.paused,\n  //           track: this._webcamProducer.track,\n  //           rtpParameters: this._webcamProducer.rtpParameters,\n  //           codec: this._webcamProducer.rtpParameters.codecs[0].mimeType.split('/')[1]\n  //         }));\n\n  //       this._webcamProducer.on('transportclose', () => {\n  //         this._webcamProducer = null;\n  //       });\n\n  //       this._webcamProducer.on('trackended', () => {\n  //         store.dispatch(requestActions.notify(\n  //           {\n  //             type: 'error',\n  //             text: intl.formatMessage({\n  //               id: 'devices.cameraDisconnected',\n  //               defaultMessage: 'Camera disconnected'\n  //             })\n  //           }));\n\n  //         this.disableWebcam();\n  //       });\n  //     }\n  //     else if (this._webcamProducer) {\n  //       ({ track } = this._webcamProducer);\n\n  //       await track.applyConstraints(\n  //         {\n  //           ...VIDEO_CONSTRAINS[resolution],\n  //           frameRate\n  //         }\n  //       );\n\n  //       // Also change resolution of extra video producers\n  //       for (const producer of this._extraVideoProducers.values()) {\n  //         ({ track } = producer);\n\n  //         await track.applyConstraints(\n  //           {\n  //             ...VIDEO_CONSTRAINS[resolution],\n  //             frameRate\n  //           }\n  //         );\n  //       }\n  //     }\n\n  //     await this._updateWebcams();\n  //   }\n  //   catch (error) {\n  //     logger.error('updateWebcam() [error:\"%o\"]', error);\n\n  //     store.dispatch(requestActions.notify(\n  //       {\n  //         type: 'error',\n  //         text: intl.formatMessage({\n  //           id: 'devices.cameraError',\n  //           defaultMessage: 'An error occurred while accessing your camera'\n  //         })\n  //       }));\n\n  //     if (track)\n  //       track.stop();\n  //   }\n\n  //   store.dispatch(\n  //     meActions.setWebcamInProgress(false));\n  // }\n\n  // async closeMeeting() {\n  //   logger.debug('closeMeeting()');\n\n  //   store.dispatch(\n  //     roomActions.setCloseMeetingInProgress(true));\n\n  //   try {\n  //     await this.sendRequest('moderator:closeMeeting');\n  //   }\n  //   catch (error) {\n  //     logger.error('closeMeeting() [error:\"%o\"]', error);\n  //   }\n\n  //   store.dispatch(\n  //     roomActions.setCloseMeetingInProgress(false));\n  // }\n\n  // // type: mic/webcam/screen\n  // // mute: true/false\n  // async modifyPeerConsumer(peerId, type, mute) {\n  //   logger.debug(\n  //     'modifyPeerConsumer() [peerId:\"%s\", type:\"%s\"]',\n  //     peerId,\n  //     type\n  //   );\n\n  //   if (type === 'mic')\n  //     store.dispatch(\n  //       peerActions.setPeerAudioInProgress(peerId, true));\n  //   else if (type === 'webcam')\n  //     store.dispatch(\n  //       peerActions.setPeerVideoInProgress(peerId, true));\n  //   else if (type === 'screen')\n  //     store.dispatch(\n  //       peerActions.setPeerScreenInProgress(peerId, true));\n\n  //   try {\n  //     for (const consumer of this._consumers.values()) {\n  //       if (consumer.appData.peerId === peerId && consumer.appData.source === type) {\n  //         if (mute)\n  //           await this._pauseConsumer(consumer);\n  //         else\n  //           await this._resumeConsumer(consumer);\n  //       }\n  //     }\n  //   }\n  //   catch (error) {\n  //     logger.error('modifyPeerConsumer() [error:\"%o\"]', error);\n  //   }\n\n  //   if (type === 'mic')\n  //     store.dispatch(\n  //       peerActions.setPeerAudioInProgress(peerId, false));\n  //   else if (type === 'webcam')\n  //     store.dispatch(\n  //       peerActions.setPeerVideoInProgress(peerId, false));\n  //   else if (type === 'screen')\n  //     store.dispatch(\n  //       peerActions.setPeerScreenInProgress(peerId, false));\n  // }\n\n  // async _pauseConsumer(consumer) {\n  //   logger.debug('_pauseConsumer() [consumer:\"%o\"]', consumer);\n\n  //   if (consumer.paused || consumer.closed)\n  //     return;\n\n  //   try {\n  //     await this.sendRequest('pauseConsumer', { consumerId: consumer.id });\n\n  //     consumer.pause();\n\n  //     store.dispatch(\n  //       consumerActions.setConsumerPaused(consumer.id, 'local'));\n  //   }\n  //   catch (error) {\n  //     logger.error('_pauseConsumer() [error:\"%o\"]', error);\n  //   }\n  // }\n\n  // async _resumeConsumer(consumer) {\n  //   logger.debug('_resumeConsumer() [consumer:\"%o\"]', consumer);\n\n  //   if (!consumer.paused || consumer.closed)\n  //     return;\n\n  //   try {\n  //     await this.sendRequest('resumeConsumer', { consumerId: consumer.id });\n\n  //     consumer.resume();\n\n  //     store.dispatch(\n  //       consumerActions.setConsumerResumed(consumer.id, 'local'));\n  //   }\n  //   catch (error) {\n  //     logger.error('_resumeConsumer() [error:\"%o\"]', error);\n  //   }\n  // }\n\n  // async setMaxSendingSpatialLayer(spatialLayer) {\n  //   logger.debug('setMaxSendingSpatialLayer() [spatialLayer:\"%s\"]', spatialLayer);\n\n  //   try {\n  //     if (this._webcamProducer)\n  //       await this._webcamProducer.setMaxSpatialLayer(spatialLayer);\n  //     if (this._screenSharingProducer)\n  //       await this._screenSharingProducer.setMaxSpatialLayer(spatialLayer);\n  //   }\n  //   catch (error) {\n  //     logger.error('setMaxSendingSpatialLayer() [error:\"%o\"]', error);\n  //   }\n  // }\n\n  // async setConsumerPreferredLayers(consumerId, spatialLayer, temporalLayer) {\n  //   logger.debug(\n  //     'setConsumerPreferredLayers() [consumerId:\"%s\", spatialLayer:\"%s\", temporalLayer:\"%s\"]',\n  //     consumerId, spatialLayer, temporalLayer);\n\n  //   try {\n  //     await this.sendRequest(\n  //       'setConsumerPreferedLayers', { consumerId, spatialLayer, temporalLayer });\n\n  //     store.dispatch(consumerActions.setConsumerPreferredLayers(\n  //       consumerId, spatialLayer, temporalLayer));\n  //   }\n  //   catch (error) {\n  //     logger.error('setConsumerPreferredLayers() [error:\"%o\"]', error);\n  //   }\n  // }\n\n  // async setConsumerPriority(consumerId, priority) {\n  //   logger.debug(\n  //     'setConsumerPriority() [consumerId:\"%s\", priority:%d]',\n  //     consumerId, priority);\n\n  //   try {\n  //     await this.sendRequest('setConsumerPriority', { consumerId, priority });\n\n  //     store.dispatch(consumerActions.setConsumerPriority(consumerId, priority));\n  //   }\n  //   catch (error) {\n  //     logger.error('setConsumerPriority() [error:\"%o\"]', error);\n  //   }\n  // }\n\n  // async requestConsumerKeyFrame(consumerId) {\n  //   logger.debug('requestConsumerKeyFrame() [consumerId:\"%s\"]', consumerId);\n\n  //   try {\n  //     await this.sendRequest('requestConsumerKeyFrame', { consumerId });\n  //   }\n  //   catch (error) {\n  //     logger.error('requestConsumerKeyFrame() [error:\"%o\"]', error);\n  //   }\n  // }\n\n\n\n\n  async join({ roomId, joinVideo, joinAudio }) {\n\n\n    this._roomId = roomId;\n\n\n    // initialize signaling socket\n    // listen to socket events\n\n    // on room ready join room _joinRoom\n\n    // this._mediasoupDevice = new mediasoupClient.Device();\n\n    // const routerRtpCapabilities =\n    //   await this.sendRequest('getRouterRtpCapabilities');\n\n    // routerRtpCapabilities.headerExtensions = routerRtpCapabilities.headerExtensions\n    //   .filter((ext) => ext.uri !== 'urn:3gpp:video-orientation');\n\n    // await this._mediasoupDevice.load({ routerRtpCapabilities });\n\n    // create send transport createWebRtcTransport this.signalingService.sendCreateTransport\n    // listen to transport events\n\n    // create receive transport this.signalingService.sendCreateTranspor\n    // listen to transport events\n\n    // send join request\n\n    // add peers to peers service\n\n    // produce updateWebcam updateMic\n  }\n\n\n}\n","/*\n * Public API Surface of hug-angular-lib\n */\n\nexport * from './lib/hug-angular-lib.service';\nexport * from './lib/hug-angular-lib.component';\nexport * from './lib/hug-angular-lib.module';\nexport * from './lib/room.service'\nexport * from './lib/room2.service'\n\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["i0.ɵɵelementStart","i0.ɵɵtext","i0.ɵɵelementEnd","LogService"],"mappings":"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"}
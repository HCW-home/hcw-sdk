/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { DEFAULT_COLOR_SCHEME } from '../resources/color-schemes';
import { NgxLoggerLevel } from '../types/logger-level.enum';
export class NGXLoggerUtils {
    /**
     * @param {?} timestamp
     * @param {?} logLevel
     * @param {?} fileName
     * @param {?} lineNumber
     * @return {?}
     */
    static prepareMetaString(timestamp, logLevel, fileName, lineNumber) {
        /** @type {?} */
        const fileDetails = fileName ? ` [${fileName}:${lineNumber}]` : '';
        return `${timestamp} ${logLevel}${fileDetails}`;
    }
    /**
     * @param {?} level
     * @param {?=} configColorScheme
     * @return {?}
     */
    static getColor(level, configColorScheme) {
        switch (level) {
            case NgxLoggerLevel.TRACE:
                return this.getColorFromConfig(NgxLoggerLevel.TRACE, configColorScheme);
            case NgxLoggerLevel.DEBUG:
                return this.getColorFromConfig(NgxLoggerLevel.DEBUG, configColorScheme);
            case NgxLoggerLevel.INFO:
                return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);
            case NgxLoggerLevel.LOG:
                return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);
            case NgxLoggerLevel.WARN:
                return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);
            case NgxLoggerLevel.ERROR:
                return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);
            case NgxLoggerLevel.FATAL:
                return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);
            case NgxLoggerLevel.OFF:
            default:
                return;
        }
    }
    /**
     * @private
     * @param {?} level
     * @param {?} configColorScheme
     * @return {?}
     */
    static getColorFromConfig(level, configColorScheme) {
        if (!configColorScheme) {
            return DEFAULT_COLOR_SCHEME[level];
        }
        return configColorScheme[level];
    }
    /**
     *  This allows us to see who called the logger
     * @return {?}
     */
    static getCallerDetails() {
        /** @type {?} */
        const err = (new Error(''));
        try {
            // this should produce the line which NGX Logger was called
            /** @type {?} */
            const callerLine = err.stack.split('\n')[4].split('/');
            // returns the file:lineNumber
            /** @type {?} */
            const fileLineNumber = callerLine[callerLine.length - 1].replace(/[)]/g, '').split(':');
            return {
                fileName: fileLineNumber[0],
                lineNumber: fileLineNumber[1]
            };
        }
        catch (e) {
            return {
                fileName: null,
                lineNumber: null
            };
        }
    }
    /**
     * @param {?} message
     * @return {?}
     */
    static prepareMessage(message) {
        try {
            if (typeof message !== 'string' && !(message instanceof Error)) {
                message = JSON.stringify(message, null, 2);
            }
        }
        catch (e) {
            // additional = [message, ...additional];
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        return message;
    }
    /**
     * @param {?} additional
     * @return {?}
     */
    static prepareAdditionalParameters(additional) {
        if (additional === null || additional === undefined) {
            return null;
        }
        return additional.map((/**
         * @param {?} next
         * @param {?} idx
         * @return {?}
         */
        (next, idx) => {
            try {
                // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                if (typeof next === 'object') {
                    JSON.stringify(next);
                }
                return next;
            }
            catch (e) {
                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;
            }
        }));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2VyLnV0aWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LWxvZ2dlci8iLCJzb3VyY2VzIjpbImxpYi91dGlscy9sb2dnZXIudXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLDRCQUE0QixDQUFDO0FBQ2hFLE9BQU8sRUFBQyxjQUFjLEVBQUMsTUFBTSw0QkFBNEIsQ0FBQztBQUUxRCxNQUFNLE9BQU8sY0FBYzs7Ozs7Ozs7SUFFekIsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFNBQWlCLEVBQUUsUUFBZ0IsRUFBRSxRQUFnQixFQUFFLFVBQWtCOztjQUMxRixXQUFXLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRTtRQUVsRSxPQUFPLEdBQUcsU0FBUyxJQUFJLFFBQVEsR0FBRyxXQUFXLEVBQUUsQ0FBQztJQUNsRCxDQUFDOzs7Ozs7SUFFRCxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQXFCLEVBQUUsaUJBQWlDO1FBQ3RFLFFBQVEsS0FBSyxFQUFFO1lBQ2IsS0FBSyxjQUFjLENBQUMsS0FBSztnQkFDdkIsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1lBQzFFLEtBQUssY0FBYyxDQUFDLEtBQUs7Z0JBQ3ZCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztZQUMxRSxLQUFLLGNBQWMsQ0FBQyxJQUFJO2dCQUN0QixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLGlCQUFpQixDQUFDLENBQUM7WUFDekUsS0FBSyxjQUFjLENBQUMsR0FBRztnQkFDckIsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3pFLEtBQUssY0FBYyxDQUFDLElBQUk7Z0JBQ3RCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxLQUFLLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztZQUMxRSxLQUFLLGNBQWMsQ0FBQyxLQUFLO2dCQUN2QixPQUFPLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLGlCQUFpQixDQUFDLENBQUM7WUFDMUUsS0FBSyxjQUFjLENBQUMsS0FBSztnQkFDdkIsT0FBTyxJQUFJLENBQUMsa0JBQWtCLENBQUMsY0FBYyxDQUFDLEtBQUssRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1lBQzFFLEtBQUssY0FBYyxDQUFDLEdBQUcsQ0FBQztZQUN4QjtnQkFDRSxPQUFPO1NBQ1Y7SUFDSCxDQUFDOzs7Ozs7O0lBRU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLEtBQWEsRUFBRSxpQkFBZ0M7UUFDL0UsSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ3RCLE9BQU8sb0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDcEM7UUFFRCxPQUFPLGlCQUFpQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2xDLENBQUM7Ozs7O0lBS0QsTUFBTSxDQUFDLGdCQUFnQjs7Y0FDZixHQUFHLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUUzQixJQUFJOzs7a0JBRUksVUFBVSxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7OztrQkFHaEQsY0FBYyxHQUFHLFVBQVUsQ0FBQyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztZQUV2RixPQUFPO2dCQUNMLFFBQVEsRUFBRSxjQUFjLENBQUMsQ0FBQyxDQUFDO2dCQUMzQixVQUFVLEVBQUUsY0FBYyxDQUFDLENBQUMsQ0FBQzthQUM5QixDQUFDO1NBQ0g7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU87Z0JBQ0wsUUFBUSxFQUFFLElBQUk7Z0JBQ2QsVUFBVSxFQUFFLElBQUk7YUFDakIsQ0FBQztTQUNIO0lBRUgsQ0FBQzs7Ozs7SUFFRCxNQUFNLENBQUMsY0FBYyxDQUFDLE9BQU87UUFDM0IsSUFBSTtZQUNGLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxJQUFJLENBQUMsQ0FBQyxPQUFPLFlBQVksS0FBSyxDQUFDLEVBQUU7Z0JBQzlELE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFDNUM7U0FDRjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YseUNBQXlDO1lBQ3pDLE9BQU8sR0FBRyx5RUFBeUUsQ0FBQztTQUNyRjtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7Ozs7O0lBRUQsTUFBTSxDQUFDLDJCQUEyQixDQUFDLFVBQWlCO1FBQ2xELElBQUksVUFBVSxLQUFLLElBQUksSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO1lBQ25ELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPLFVBQVUsQ0FBQyxHQUFHOzs7OztRQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFFO1lBQ2xDLElBQUk7Z0JBQ0YsK0ZBQStGO2dCQUMvRixJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsRUFBRTtvQkFDNUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztpQkFDdEI7Z0JBRUQsT0FBTyxJQUFJLENBQUM7YUFDYjtZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sa0JBQWtCLEdBQUcscURBQXFELENBQUM7YUFDbkY7UUFDSCxDQUFDLEVBQUMsQ0FBQztJQUNMLENBQUM7Q0FFRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7REVGQVVMVF9DT0xPUl9TQ0hFTUV9IGZyb20gJy4uL3Jlc291cmNlcy9jb2xvci1zY2hlbWVzJztcbmltcG9ydCB7Tmd4TG9nZ2VyTGV2ZWx9IGZyb20gJy4uL3R5cGVzL2xvZ2dlci1sZXZlbC5lbnVtJztcblxuZXhwb3J0IGNsYXNzIE5HWExvZ2dlclV0aWxzIHtcblxuICBzdGF0aWMgcHJlcGFyZU1ldGFTdHJpbmcodGltZXN0YW1wOiBzdHJpbmcsIGxvZ0xldmVsOiBzdHJpbmcsIGZpbGVOYW1lOiBzdHJpbmcsIGxpbmVOdW1iZXI6IHN0cmluZykge1xuICAgIGNvbnN0IGZpbGVEZXRhaWxzID0gZmlsZU5hbWUgPyBgIFske2ZpbGVOYW1lfToke2xpbmVOdW1iZXJ9XWAgOiAnJztcblxuICAgIHJldHVybiBgJHt0aW1lc3RhbXB9ICR7bG9nTGV2ZWx9JHtmaWxlRGV0YWlsc31gO1xuICB9XG5cbiAgc3RhdGljIGdldENvbG9yKGxldmVsOiBOZ3hMb2dnZXJMZXZlbCwgY29uZmlnQ29sb3JTY2hlbWU/OiBBcnJheTxzdHJpbmc+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICBjYXNlIE5neExvZ2dlckxldmVsLlRSQUNFOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xvckZyb21Db25maWcoTmd4TG9nZ2VyTGV2ZWwuVFJBQ0UsIGNvbmZpZ0NvbG9yU2NoZW1lKTtcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuREVCVUc6XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbG9yRnJvbUNvbmZpZyhOZ3hMb2dnZXJMZXZlbC5ERUJVRywgY29uZmlnQ29sb3JTY2hlbWUpO1xuICAgICAgY2FzZSBOZ3hMb2dnZXJMZXZlbC5JTkZPOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xvckZyb21Db25maWcoTmd4TG9nZ2VyTGV2ZWwuSU5GTywgY29uZmlnQ29sb3JTY2hlbWUpO1xuICAgICAgY2FzZSBOZ3hMb2dnZXJMZXZlbC5MT0c6XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbG9yRnJvbUNvbmZpZyhOZ3hMb2dnZXJMZXZlbC5JTkZPLCBjb25maWdDb2xvclNjaGVtZSk7XG4gICAgICBjYXNlIE5neExvZ2dlckxldmVsLldBUk46XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbG9yRnJvbUNvbmZpZyhOZ3hMb2dnZXJMZXZlbC5GQVRBTCwgY29uZmlnQ29sb3JTY2hlbWUpO1xuICAgICAgY2FzZSBOZ3hMb2dnZXJMZXZlbC5FUlJPUjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sb3JGcm9tQ29uZmlnKE5neExvZ2dlckxldmVsLkZBVEFMLCBjb25maWdDb2xvclNjaGVtZSk7XG4gICAgICBjYXNlIE5neExvZ2dlckxldmVsLkZBVEFMOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2xvckZyb21Db25maWcoTmd4TG9nZ2VyTGV2ZWwuRkFUQUwsIGNvbmZpZ0NvbG9yU2NoZW1lKTtcbiAgICAgIGNhc2UgTmd4TG9nZ2VyTGV2ZWwuT0ZGOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldENvbG9yRnJvbUNvbmZpZyhsZXZlbDogbnVtYmVyLCBjb25maWdDb2xvclNjaGVtZTogQXJyYXk8c3RyaW5nPik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFjb25maWdDb2xvclNjaGVtZSkge1xuICAgICAgcmV0dXJuIERFRkFVTFRfQ09MT1JfU0NIRU1FW2xldmVsXTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29uZmlnQ29sb3JTY2hlbWVbbGV2ZWxdO1xuICB9XG5cbiAgLyoqXG4gICAqICBUaGlzIGFsbG93cyB1cyB0byBzZWUgd2hvIGNhbGxlZCB0aGUgbG9nZ2VyXG4gICAqL1xuICBzdGF0aWMgZ2V0Q2FsbGVyRGV0YWlscygpOiB7IGxpbmVOdW1iZXI6IHN0cmluZywgZmlsZU5hbWU6IHN0cmluZyB9IHtcbiAgICBjb25zdCBlcnIgPSAobmV3IEVycm9yKCcnKSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gdGhpcyBzaG91bGQgcHJvZHVjZSB0aGUgbGluZSB3aGljaCBOR1ggTG9nZ2VyIHdhcyBjYWxsZWRcbiAgICAgIGNvbnN0IGNhbGxlckxpbmUgPSBlcnIuc3RhY2suc3BsaXQoJ1xcbicpWzRdLnNwbGl0KCcvJyk7XG5cbiAgICAgIC8vIHJldHVybnMgdGhlIGZpbGU6bGluZU51bWJlclxuICAgICAgY29uc3QgZmlsZUxpbmVOdW1iZXIgPSBjYWxsZXJMaW5lW2NhbGxlckxpbmUubGVuZ3RoIC0gMV0ucmVwbGFjZSgvWyldL2csICcnKS5zcGxpdCgnOicpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWxlTmFtZTogZmlsZUxpbmVOdW1iZXJbMF0sXG4gICAgICAgIGxpbmVOdW1iZXI6IGZpbGVMaW5lTnVtYmVyWzFdXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVOYW1lOiBudWxsLFxuICAgICAgICBsaW5lTnVtYmVyOiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICB9XG5cbiAgc3RhdGljIHByZXBhcmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJyAmJiAhKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIGFkZGl0aW9uYWwgPSBbbWVzc2FnZSwgLi4uYWRkaXRpb25hbF07XG4gICAgICBtZXNzYWdlID0gJ1RoZSBwcm92aWRlZCBcIm1lc3NhZ2VcIiB2YWx1ZSBjb3VsZCBub3QgYmUgcGFyc2VkIHdpdGggSlNPTi5zdHJpbmdpZnkoKS4nO1xuICAgIH1cblxuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG5cbiAgc3RhdGljIHByZXBhcmVBZGRpdGlvbmFsUGFyYW1ldGVycyhhZGRpdGlvbmFsOiBhbnlbXSkge1xuICAgIGlmIChhZGRpdGlvbmFsID09PSBudWxsIHx8IGFkZGl0aW9uYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGl0aW9uYWwubWFwKChuZXh0LCBpZHgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUgdGhlIEpTT04gY2FuIGJlIHBhcnNlZCwgd2UgZG8gbm90IHdhbnQgdG8gYWN0dWFsbHkgY2hhbmdlIHRoZSB0eXBlXG4gICAgICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gYFRoZSBhZGRpdGlvbmFsWyR7aWR4fV0gdmFsdWUgY291bGQgbm90IGJlIHBhcnNlZCB1c2luZyBKU09OLnN0cmluZ2lmeSgpLmA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuIl19
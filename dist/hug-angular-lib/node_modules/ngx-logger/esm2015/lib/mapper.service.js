/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';
import * as vlq from 'vlq';
import { of } from 'rxjs';
import { catchError, filter, map, retry, shareReplay, switchMap } from 'rxjs/operators';
import { LogPosition } from './types/log-position';
export class NGXMapperService {
    /**
     * @param {?} httpBackend
     */
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
        // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'
        this.sourceMapCache = new Map();
        // cache for specific log position, key is the dist position, ie 'main.js:339:21'
        this.logPositionCache = new Map();
    }
    /*
      Static Functions
     */
    /**
     * @private
     * @return {?}
     */
    static getStackLine() {
        /** @type {?} */
        const error = new Error();
        try {
            // noinspection ExceptionCaughtLocallyJS
            throw error;
        }
        catch (e) {
            try {
                return error.stack.split('\n')[5];
            }
            catch (e) {
                return null;
            }
        }
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getPosition(stackLine) {
        // strip base path, then parse filename, line, and column
        /** @type {?} */
        const positionStartIndex = stackLine.lastIndexOf('\/');
        /** @type {?} */
        let positionEndIndex = stackLine.indexOf(')');
        if (positionEndIndex < 0) {
            positionEndIndex = undefined;
        }
        /** @type {?} */
        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);
        /** @type {?} */
        const dataArray = position.split(':');
        if (dataArray.length === 3) {
            return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);
        }
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getTranspileLocation(stackLine) {
        /** @type {?} */
        let locationStartIndex = stackLine.indexOf('(');
        if (locationStartIndex < 0) {
            locationStartIndex = stackLine.lastIndexOf(' ');
        }
        /** @type {?} */
        let locationEndIndex = stackLine.indexOf(')');
        if (locationEndIndex < 0) {
            locationEndIndex = undefined;
        }
        return stackLine.substring(locationStartIndex + 1, locationEndIndex);
    }
    /**
     * @private
     * @param {?} stackLine
     * @return {?}
     */
    static getMapFilePath(stackLine) {
        /** @type {?} */
        const file = NGXMapperService.getTranspileLocation(stackLine);
        /** @type {?} */
        const mapFullPath = file.substring(0, file.lastIndexOf(':'));
        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';
    }
    /**
     * @private
     * @param {?} sourceMap
     * @param {?} position
     * @return {?}
     */
    static getMapping(sourceMap, position) {
        // => ';' indicates end of a line
        // => ',' separates mappings in a line
        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]
        /** @type {?} */
        let sourceFileIndex = 0;
        /** @type {?} */
        let // second field
        sourceCodeLine = 0;
        /** @type {?} */
        let // third field
        sourceCodeColumn = 0;
        // fourth field
        /** @type {?} */
        const lines = sourceMap.mappings.split(';');
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            // reset column position to 0 after each line
            /** @type {?} */
            let generatedCodeColumn = 0;
            // decode sections in line
            /** @type {?} */
            const columns = lines[lineIndex].split(',');
            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {
                /** @type {?} */
                const decodedSection = vlq.decode(columns[columnIndex]);
                if (decodedSection.length >= 4) {
                    // update relative positions
                    generatedCodeColumn += decodedSection[0];
                    sourceFileIndex += decodedSection[1];
                    sourceCodeLine += decodedSection[2];
                    sourceCodeColumn += decodedSection[3];
                }
                // check if matching map
                if (lineIndex === position.lineNumber) {
                    if (generatedCodeColumn === position.columnNumber) {
                        // matching column and line found
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);
                    }
                    else if (columnIndex + 1 === columns.length) {
                        // matching column not found, but line is correct
                        return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);
                    }
                }
            }
        }
        // failed if reached
        return new LogPosition('unknown', 0, 0);
    }
    /**
     * does the http get request to get the source map
     * @private
     * @param {?} sourceMapLocation
     * @param {?} distPosition
     * @return {?}
     */
    _getSourceMap(sourceMapLocation, distPosition) {
        /** @type {?} */
        const req = new HttpRequest('GET', sourceMapLocation);
        /** @type {?} */
        const distPositionKey = distPosition.toString();
        // if the specific log position is already in cache return it
        if (this.logPositionCache.has(distPositionKey)) {
            return this.logPositionCache.get(distPositionKey);
        }
        // otherwise check if the source map is already cached for given source map location
        if (!this.sourceMapCache.has(sourceMapLocation)) {
            // obtain the source map if not cached
            this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((/**
             * @param {?} e
             * @return {?}
             */
            (e) => e instanceof HttpResponse)), map((/**
             * @param {?} httpResponse
             * @return {?}
             */
            (httpResponse) => httpResponse.body)), retry(3), shareReplay(1)));
        }
        // at this point the source map is cached, use it to get specific log position mapping
        /** @type {?} */
        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((/**
         * @param {?} sourceMap
         * @return {?}
         */
        (sourceMap) => 
        // map generated position to source position
        NGXMapperService.getMapping(sourceMap, distPosition))), catchError((/**
         * @return {?}
         */
        () => of(distPosition))), shareReplay(1));
        // store specific log position in cache for given dest position and return it
        this.logPositionCache.set(distPositionKey, logPosition$);
        return logPosition$;
    }
    /**
     * Returns the LogPosition for the current log
     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name
     * and number of the call
     * @param {?} sourceMapsEnabled
     * @return {?}
     */
    getCallerDetails(sourceMapsEnabled) {
        // parse generated file mapping from stack trace
        // parse generated file mapping from stack trace
        /** @type {?} */
        const stackLine = NGXMapperService.getStackLine();
        // if we were not able to parse the stackLine, just return an empty Log Position
        if (!stackLine) {
            return of(new LogPosition('', 0, 0));
        }
        return of([
            NGXMapperService.getPosition(stackLine),
            NGXMapperService.getMapFilePath(stackLine)
        ]).pipe(switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([distPosition, sourceMapLocation]) => {
            // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,
            // then just use the position of the JS instead of the source
            if (!sourceMapsEnabled) {
                return of(distPosition);
            }
            // finally try to get the source map and return the position
            return this._getSourceMap(sourceMapLocation, distPosition);
        })));
    }
}
NGXMapperService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NGXMapperService.ctorParameters = () => [
    { type: HttpBackend }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.sourceMapCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.logPositionCache;
    /**
     * @type {?}
     * @private
     */
    NGXMapperService.prototype.httpBackend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtbG9nZ2VyLyIsInNvdXJjZXMiOlsibGliL21hcHBlci5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFDQSxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQzVFLE9BQU8sS0FBSyxHQUFHLE1BQU0sS0FBSyxDQUFDO0FBQzNCLE9BQU8sRUFBYSxFQUFFLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFDcEMsT0FBTyxFQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEYsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBR2pELE1BQU0sT0FBTyxnQkFBZ0I7Ozs7SUFRM0IsWUFBb0IsV0FBd0I7UUFBeEIsZ0JBQVcsR0FBWCxXQUFXLENBQWE7O1FBTHBDLG1CQUFjLEdBQXVDLElBQUksR0FBRyxFQUFFLENBQUM7O1FBRy9ELHFCQUFnQixHQUF5QyxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBRzNFLENBQUM7Ozs7Ozs7O0lBS08sTUFBTSxDQUFDLFlBQVk7O2NBQ25CLEtBQUssR0FBRyxJQUFJLEtBQUssRUFBRTtRQUV6QixJQUFJO1lBQ0Ysd0NBQXdDO1lBQ3hDLE1BQU0sS0FBSyxDQUFDO1NBQ2I7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUVWLElBQUk7Z0JBQ0YsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUNuQztZQUFDLE9BQU8sQ0FBQyxFQUFFO2dCQUNWLE9BQU8sSUFBSSxDQUFDO2FBQ2I7U0FDRjtJQUNILENBQUM7Ozs7OztJQUVPLE1B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QUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEM7UUFFRCxPQUFPLEVBQUUsQ0FBQztZQUNSLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUM7WUFDdkMsZ0JBQWdCLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQztTQUMzQyxDQUFDLENBQUMsSUFBSSxDQUNMLFNBQVM7Ozs7UUFBaUQsQ0FBQyxDQUFDLFlBQVksRUFBRSxpQkFBaUIsQ0FBQyxFQUFFLEVBQUU7WUFFOUYsd0dBQXdHO1lBQ3hHLDZEQUE2RDtZQUM3RCxJQUFJLENBQUMsaUJBQWlCLEVBQUU7Z0JBQ3RCLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ3pCO1lBRUQsNERBQTREO1lBQzVELE9BQU8sSUFBSSxDQUFDLGFBQWEsQ0FBQyxpQkFBaUIsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUM3RCxDQUFDLEVBQUMsQ0FDSCxDQUFDO0lBR0osQ0FBQzs7O1lBN0xGLFVBQVU7Ozs7WUFOSCxXQUFXOzs7Ozs7O0lBVWpCLDBDQUF1RTs7Ozs7SUFHdkUsNENBQTJFOzs7OztJQUUvRCx1Q0FBZ0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1NvdXJjZU1hcH0gZnJvbSAnQGFuZ3VsYXIvY29tcGlsZXInO1xuaW1wb3J0IHtJbmplY3RhYmxlfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7SHR0cEJhY2tlbmQsIEh0dHBSZXF1ZXN0LCBIdHRwUmVzcG9uc2V9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCAqIGFzIHZscSBmcm9tICd2bHEnO1xuaW1wb3J0IHtPYnNlcnZhYmxlLCBvZn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge2NhdGNoRXJyb3IsIGZpbHRlciwgbWFwLCByZXRyeSwgc2hhcmVSZXBsYXksIHN3aXRjaE1hcH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtMb2dQb3NpdGlvbn0gZnJvbSAnLi90eXBlcy9sb2ctcG9zaXRpb24nO1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTkdYTWFwcGVyU2VydmljZSB7XG5cbiAgLy8gY2FjaGUgZm9yIHNvdXJjZSBtYXBzLCBrZXkgaXMgc291cmNlIG1hcCBsb2NhdGlvbiwgaWUuICdodHRwOi8vbG9jYWxob3N0OjQyMDAvbWFpbi5qcy5tYXAnXG4gIHByaXZhdGUgc291cmNlTWFwQ2FjaGU6IE1hcDxzdHJpbmcsIE9ic2VydmFibGU8U291cmNlTWFwPj4gPSBuZXcgTWFwKCk7XG5cbiAgLy8gY2FjaGUgZm9yIHNwZWNpZmljIGxvZyBwb3NpdGlvbiwga2V5IGlzIHRoZSBkaXN0IHBvc2l0aW9uLCBpZSAnbWFpbi5qczozMzk6MjEnXG4gIHByaXZhdGUgbG9nUG9zaXRpb25DYWNoZTogTWFwPHN0cmluZywgT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4+ID0gbmV3IE1hcCgpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaHR0cEJhY2tlbmQ6IEh0dHBCYWNrZW5kKSB7XG4gIH1cblxuICAvKlxuICBTdGF0aWMgRnVuY3Rpb25zXG4gKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3RhY2tMaW5lKCk6IHN0cmluZyB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBub2luc3BlY3Rpb24gRXhjZXB0aW9uQ2F1Z2h0TG9jYWxseUpTXG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBlcnJvci5zdGFjay5zcGxpdCgnXFxuJylbNV07XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldFBvc2l0aW9uKHN0YWNrTGluZTogc3RyaW5nKTogTG9nUG9zaXRpb24ge1xuICAgIC8vIHN0cmlwIGJhc2UgcGF0aCwgdGhlbiBwYXJzZSBmaWxlbmFtZSwgbGluZSwgYW5kIGNvbHVtblxuICAgIGNvbnN0IHBvc2l0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5sYXN0SW5kZXhPZignXFwvJyk7XG4gICAgbGV0IHBvc2l0aW9uRW5kSW5kZXggPSBzdGFja0xpbmUuaW5kZXhPZignKScpO1xuICAgIGlmIChwb3NpdGlvbkVuZEluZGV4IDwgMCkge1xuICAgICAgcG9zaXRpb25FbmRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBwb3NpdGlvbiA9IHN0YWNrTGluZS5zdWJzdHJpbmcocG9zaXRpb25TdGFydEluZGV4ICsgMSwgcG9zaXRpb25FbmRJbmRleCk7XG4gICAgY29uc3QgZGF0YUFycmF5ID0gcG9zaXRpb24uc3BsaXQoJzonKTtcbiAgICBpZiAoZGF0YUFycmF5Lmxlbmd0aCA9PT0gMykge1xuICAgICAgcmV0dXJuIG5ldyBMb2dQb3NpdGlvbihkYXRhQXJyYXlbMF0sICtkYXRhQXJyYXlbMV0sICtkYXRhQXJyYXlbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKCd1bmtub3duJywgMCwgMCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRUcmFuc3BpbGVMb2NhdGlvbihzdGFja0xpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgbGV0IGxvY2F0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5pbmRleE9mKCcoJyk7XG4gICAgaWYgKGxvY2F0aW9uU3RhcnRJbmRleCA8IDApIHtcbiAgICAgIGxvY2F0aW9uU3RhcnRJbmRleCA9IHN0YWNrTGluZS5sYXN0SW5kZXhPZignICcpO1xuICAgIH1cblxuICAgIGxldCBsb2NhdGlvbkVuZEluZGV4ID0gc3RhY2tMaW5lLmluZGV4T2YoJyknKTtcbiAgICBpZiAobG9jYXRpb25FbmRJbmRleCA8IDApIHtcbiAgICAgIGxvY2F0aW9uRW5kSW5kZXggPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YWNrTGluZS5zdWJzdHJpbmcobG9jYXRpb25TdGFydEluZGV4ICsgMSwgbG9jYXRpb25FbmRJbmRleCk7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRNYXBGaWxlUGF0aChzdGFja0xpbmU6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgZmlsZSA9IE5HWE1hcHBlclNlcnZpY2UuZ2V0VHJhbnNwaWxlTG9jYXRpb24oc3RhY2tMaW5lKTtcbiAgICBjb25zdCBtYXBGdWxsUGF0aCA9IGZpbGUuc3Vic3RyaW5nKDAsIGZpbGUubGFzdEluZGV4T2YoJzonKSk7XG4gICAgcmV0dXJuIG1hcEZ1bGxQYXRoLnN1YnN0cmluZygwLCBtYXBGdWxsUGF0aC5sYXN0SW5kZXhPZignOicpKSArICcubWFwJztcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGdldE1hcHBpbmcoc291cmNlTWFwOiBTb3VyY2VNYXAsIHBvc2l0aW9uOiBMb2dQb3NpdGlvbik6IExvZ1Bvc2l0aW9uIHtcbiAgICAvLyA9PiAnOycgaW5kaWNhdGVzIGVuZCBvZiBhIGxpbmVcbiAgICAvLyA9PiAnLCcgc2VwYXJhdGVzIG1hcHBpbmdzIGluIGEgbGluZVxuICAgIC8vIGRlY29kZWQgbWFwcGluZyA9PiBbIGdlbmVyYXRlZENvZGVDb2x1bW4sIHNvdXJjZUZpbGVJbmRleCwgc291cmNlQ29kZUxpbmUsIHNvdXJjZUNvZGVDb2x1bW4sIG5hbWVJbmRleCBdXG4gICAgbGV0IHNvdXJjZUZpbGVJbmRleCA9IDAsICAgLy8gc2Vjb25kIGZpZWxkXG4gICAgICBzb3VyY2VDb2RlTGluZSA9IDAsICAgIC8vIHRoaXJkIGZpZWxkXG4gICAgICBzb3VyY2VDb2RlQ29sdW1uID0gMDsgIC8vIGZvdXJ0aCBmaWVsZFxuXG4gICAgY29uc3QgbGluZXMgPSBzb3VyY2VNYXAubWFwcGluZ3Muc3BsaXQoJzsnKTtcblxuICAgIGZvciAobGV0IGxpbmVJbmRleCA9IDA7IGxpbmVJbmRleCA8IGxpbmVzLmxlbmd0aDsgbGluZUluZGV4KyspIHtcbiAgICAgIC8vIHJlc2V0IGNvbHVtbiBwb3NpdGlvbiB0byAwIGFmdGVyIGVhY2ggbGluZVxuICAgICAgbGV0IGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuICAgICAgLy8gZGVjb2RlIHNlY3Rpb25zIGluIGxpbmVcbiAgICAgIGNvbnN0IGNvbHVtbnMgPSBsaW5lc1tsaW5lSW5kZXhdLnNwbGl0KCcsJyk7XG5cbiAgICAgIGZvciAobGV0IGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCBjb2x1bW5zLmxlbmd0aDsgY29sdW1uSW5kZXgrKykge1xuICAgICAgICBjb25zdCBkZWNvZGVkU2VjdGlvbiA9IHZscS5kZWNvZGUoY29sdW1uc1tjb2x1bW5JbmRleF0pO1xuICAgICAgICBpZiAoZGVjb2RlZFNlY3Rpb24ubGVuZ3RoID49IDQpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgICAgICAgZ2VuZXJhdGVkQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblswXTtcbiAgICAgICAgICBzb3VyY2VGaWxlSW5kZXggKz0gZGVjb2RlZFNlY3Rpb25bMV07XG4gICAgICAgICAgc291cmNlQ29kZUxpbmUgKz0gZGVjb2RlZFNlY3Rpb25bMl07XG4gICAgICAgICAgc291cmNlQ29kZUNvbHVtbiArPSBkZWNvZGVkU2VjdGlvblszXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoZWNrIGlmIG1hdGNoaW5nIG1hcFxuICAgICAgICBpZiAobGluZUluZGV4ID09PSBwb3NpdGlvbi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgaWYgKGdlbmVyYXRlZENvZGVDb2x1bW4gPT09IHBvc2l0aW9uLmNvbHVtbk51bWJlcikge1xuICAgICAgICAgICAgLy8gbWF0Y2hpbmcgY29sdW1uIGFuZCBsaW5lIGZvdW5kXG4gICAgICAgICAgICByZXR1cm4gbmV3IExvZ1Bvc2l0aW9uKHNvdXJjZU1hcC5zb3VyY2VzW3NvdXJjZUZpbGVJbmRleF0sIHNvdXJjZUNvZGVMaW5lLCBzb3VyY2VDb2RlQ29sdW1uKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbHVtbkluZGV4ICsgMSA9PT0gY29sdW1ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGNvbHVtbiBub3QgZm91bmQsIGJ1dCBsaW5lIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oc291cmNlTWFwLnNvdXJjZXNbc291cmNlRmlsZUluZGV4XSwgc291cmNlQ29kZUxpbmUsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBmYWlsZWQgaWYgcmVhY2hlZFxuICAgIHJldHVybiBuZXcgTG9nUG9zaXRpb24oJ3Vua25vd24nLCAwLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBkb2VzIHRoZSBodHRwIGdldCByZXF1ZXN0IHRvIGdldCB0aGUgc291cmNlIG1hcFxuICAgKiBAcGFyYW0gc291cmNlTWFwTG9jYXRpb25cbiAgICogQHBhcmFtIGRpc3RQb3NpdGlvblxuICAgKi9cbiAgcHJpdmF0ZSBfZ2V0U291cmNlTWFwKHNvdXJjZU1hcExvY2F0aW9uOiBzdHJpbmcsIGRpc3RQb3NpdGlvbjogTG9nUG9zaXRpb24pOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XG4gICAgY29uc3QgcmVxID0gbmV3IEh0dHBSZXF1ZXN0PFNvdXJjZU1hcD4oJ0dFVCcsIHNvdXJjZU1hcExvY2F0aW9uKTtcbiAgICBjb25zdCBkaXN0UG9zaXRpb25LZXkgPSBkaXN0UG9zaXRpb24udG9TdHJpbmcoKTtcblxuICAgIC8vIGlmIHRoZSBzcGVjaWZpYyBsb2cgcG9zaXRpb24gaXMgYWxyZWFkeSBpbiBjYWNoZSByZXR1cm4gaXRcbiAgICBpZiAodGhpcy5sb2dQb3NpdGlvbkNhY2hlLmhhcyhkaXN0UG9zaXRpb25LZXkpKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2dQb3NpdGlvbkNhY2hlLmdldChkaXN0UG9zaXRpb25LZXkpO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBjaGVjayBpZiB0aGUgc291cmNlIG1hcCBpcyBhbHJlYWR5IGNhY2hlZCBmb3IgZ2l2ZW4gc291cmNlIG1hcCBsb2NhdGlvblxuICAgIGlmICghdGhpcy5zb3VyY2VNYXBDYWNoZS5oYXMoc291cmNlTWFwTG9jYXRpb24pKSB7XG4gICAgICAvLyBvYnRhaW4gdGhlIHNvdXJjZSBtYXAgaWYgbm90IGNhY2hlZFxuICAgICAgdGhpcy5zb3VyY2VNYXBDYWNoZS5zZXQoXG4gICAgICAgIHNvdXJjZU1hcExvY2F0aW9uLFxuICAgICAgICB0aGlzLmh0dHBCYWNrZW5kLmhhbmRsZShyZXEpLnBpcGUoXG4gICAgICAgICAgZmlsdGVyKChlKSA9PiBlIGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSxcbiAgICAgICAgICBtYXA8SHR0cFJlc3BvbnNlPFNvdXJjZU1hcD4sIFNvdXJjZU1hcD4oXG4gICAgICAgICAgICAoaHR0cFJlc3BvbnNlOiBIdHRwUmVzcG9uc2U8U291cmNlTWFwPikgPT4gaHR0cFJlc3BvbnNlLmJvZHlcbiAgICAgICAgICApLFxuICAgICAgICAgIHJldHJ5KDMpLFxuICAgICAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCB0aGUgc291cmNlIG1hcCBpcyBjYWNoZWQsIHVzZSBpdCB0byBnZXQgc3BlY2lmaWMgbG9nIHBvc2l0aW9uIG1hcHBpbmdcbiAgICBjb25zdCBsb2dQb3NpdGlvbiQgPSB0aGlzLnNvdXJjZU1hcENhY2hlLmdldChzb3VyY2VNYXBMb2NhdGlvbikucGlwZShcbiAgICAgIG1hcDxTb3VyY2VNYXAsIExvZ1Bvc2l0aW9uPigoc291cmNlTWFwKSA9PlxuICAgICAgICAvLyBtYXAgZ2VuZXJhdGVkIHBvc2l0aW9uIHRvIHNvdXJjZSBwb3NpdGlvblxuICAgICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcHBpbmcoc291cmNlTWFwLCBkaXN0UG9zaXRpb24pXG4gICAgICApLFxuICAgICAgY2F0Y2hFcnJvcigoKSA9PiBvZihkaXN0UG9zaXRpb24pKSxcbiAgICAgIHNoYXJlUmVwbGF5KDEpXG4gICAgKTtcblxuICAgIC8vIHN0b3JlIHNwZWNpZmljIGxvZyBwb3NpdGlvbiBpbiBjYWNoZSBmb3IgZ2l2ZW4gZGVzdCBwb3NpdGlvbiBhbmQgcmV0dXJuIGl0XG4gICAgdGhpcy5sb2dQb3NpdGlvbkNhY2hlLnNldChkaXN0UG9zaXRpb25LZXksIGxvZ1Bvc2l0aW9uJCk7XG5cbiAgICByZXR1cm4gbG9nUG9zaXRpb24kO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIExvZ1Bvc2l0aW9uIGZvciB0aGUgY3VycmVudCBsb2dcbiAgICogSWYgc291cmNlTWFwcyBhcmUgZW5hYmxlZCwgaXQgYXR0ZW1wcyB0byBnZXQgdGhlIHNvdXJjZSBtYXAgZnJvbSB0aGUgc2VydmVyLCBhbmQgdXNlIHRoYXQgdG8gcGFyc2UgdGhlIGZpbGUgbmFtZVxuICAgKiBhbmQgbnVtYmVyIG9mIHRoZSBjYWxsXG4gICAqIEBwYXJhbSBzb3VyY2VNYXBzRW5hYmxlZFxuICAgKi9cbiAgcHVibGljIGdldENhbGxlckRldGFpbHMoc291cmNlTWFwc0VuYWJsZWQ6IGJvb2xlYW4pOiBPYnNlcnZhYmxlPExvZ1Bvc2l0aW9uPiB7XG4gICAgLy8gcGFyc2UgZ2VuZXJhdGVkIGZpbGUgbWFwcGluZyBmcm9tIHN0YWNrIHRyYWNlXG5cbiAgICBjb25zdCBzdGFja0xpbmUgPSBOR1hNYXBwZXJTZXJ2aWNlLmdldFN0YWNrTGluZSgpO1xuXG4gICAgLy8gaWYgd2Ugd2VyZSBub3QgYWJsZSB0byBwYXJzZSB0aGUgc3RhY2tMaW5lLCBqdXN0IHJldHVybiBhbiBlbXB0eSBMb2cgUG9zaXRpb25cbiAgICBpZiAoIXN0YWNrTGluZSkge1xuICAgICAgcmV0dXJuIG9mKG5ldyBMb2dQb3NpdGlvbignJywgMCwgMCkpO1xuICAgIH1cblxuICAgIHJldHVybiBvZihbXG4gICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldFBvc2l0aW9uKHN0YWNrTGluZSksXG4gICAgICBOR1hNYXBwZXJTZXJ2aWNlLmdldE1hcEZpbGVQYXRoKHN0YWNrTGluZSlcbiAgICBdKS5waXBlKFxuICAgICAgc3dpdGNoTWFwPFtMb2dQb3NpdGlvbiwgc3RyaW5nXSwgT2JzZXJ2YWJsZTxMb2dQb3NpdGlvbj4+KChbZGlzdFBvc2l0aW9uLCBzb3VyY2VNYXBMb2NhdGlvbl0pID0+IHtcblxuICAgICAgICAvLyBpZiBzb3VyY2UgbWFwcyBhcmUgbm90IGVuYWJsZWQsIG9yIGlmIHdlJ3ZlIHByZXZpb3VzbHkgdHJpZWQgdG8gZ2V0IHRoZSBzb3VyY2UgbWFwcywgYnV0IHRoZXkgZmFpbGVkLFxuICAgICAgICAvLyB0aGVuIGp1c3QgdXNlIHRoZSBwb3NpdGlvbiBvZiB0aGUgSlMgaW5zdGVhZCBvZiB0aGUgc291cmNlXG4gICAgICAgIGlmICghc291cmNlTWFwc0VuYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm4gb2YoZGlzdFBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmFsbHkgdHJ5IHRvIGdldCB0aGUgc291cmNlIG1hcCBhbmQgcmV0dXJuIHRoZSBwb3NpdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U291cmNlTWFwKHNvdXJjZU1hcExvY2F0aW9uLCBkaXN0UG9zaXRpb24pO1xuICAgICAgfSlcbiAgICApO1xuXG5cbiAgfVxufVxuXG5cblxuXG4iXX0=
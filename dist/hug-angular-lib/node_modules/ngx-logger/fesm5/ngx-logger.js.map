{"version":3,"file":"ngx-logger.js","sources":["ng://ngx-logger/lib/http.service.ts","ng://ngx-logger/lib/types/logger-level.enum.ts","ng://ngx-logger/lib/logger.config.ts","ng://ngx-logger/lib/config.engine.ts","ng://ngx-logger/lib/resources/color-schemes.ts","ng://ngx-logger/lib/utils/logger.utils.ts","ng://ngx-logger/lib/types/log-position.ts","ng://ngx-logger/lib/mapper.service.ts","ng://ngx-logger/lib/logger.service.ts","ng://ngx-logger/lib/custom-logger.service.ts","ng://ngx-logger/lib/logger.module.ts","ng://ngx-logger/lib/logger-monitor.ts","ng://ngx-logger/lib/types/ngx-log.interface.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport {HttpBackend, HttpRequest, HttpResponse} from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport {filter, map} from 'rxjs/operators';\nimport { NGXLogInterface } from './types/ngx-log.interface';\n\n\n\n@Injectable()\nexport class NGXLoggerHttpService {\n  constructor(private readonly httpBackend: HttpBackend) { }\n\n  logOnServer(url: string, log: NGXLogInterface, options: object): Observable<any> {\n    // HttpBackend skips all HttpInterceptors\n    // They may log errors using this service causing circular calls\n    const req = new HttpRequest<any>('POST', url, log, options || {});\n    return this.httpBackend.handle(req).pipe(\n      filter(e => e instanceof HttpResponse),\n      map<HttpResponse<any>, any>((httpResponse: HttpResponse<any>) => httpResponse.body)\n    );\n  }\n\n}\n","export enum NgxLoggerLevel {\n  TRACE = 0,\n  DEBUG = 1,\n  INFO = 2,\n  LOG = 3,\n  WARN = 4,\n  ERROR = 5,\n  FATAL = 6,\n  OFF = 7\n}\n","import {LoggerColorScheme} from './types/logger-color-scheme';\nimport {NgxLoggerLevel} from './types/logger-level.enum';\n\nexport class LoggerConfig {\n  level: NgxLoggerLevel;\n  serverLogLevel?: NgxLoggerLevel;\n  serverLoggingUrl?: string;\n  disableConsoleLogging?: boolean;\n  httpResponseType?: 'arraybuffer' | 'blob' | 'text' | 'json';\n  enableSourceMaps?: boolean;\n  /** Timestamp format: any format accepted by Angular DatePipe. Defaults to ISOString */\n  timestampFormat?: string;\n  colorScheme?: LoggerColorScheme;\n}\n","import {LoggerConfig} from './logger.config';\n\nexport class NGXLoggerConfigEngine {\n\n  private _config;\n  constructor(readonly config: LoggerConfig) {\n    this._config = config;\n  }\n\n  updateConfig(config: LoggerConfig) {\n    this._config = this._clone(config);\n  }\n\n  getConfig() {\n    return this._clone(this._config);\n  }\n\n  // TODO: add tests around cloning the config. updating an object passed into the config (or retrieving from the config)\n  // should not update the active config, this is a shallow clone. If our config ever becomes hierarchical we must make\n  // this a deep clone\n  private _clone(object: any) {\n    const cloneConfig: LoggerConfig = new LoggerConfig();\n\n    Object.keys(object).forEach((key) => {\n      cloneConfig[key] = object[key];\n    });\n\n    return cloneConfig;\n  }\n}\n","import {LoggerColorScheme} from '../types/logger-color-scheme';\n\nexport const DEFAULT_COLOR_SCHEME: LoggerColorScheme = [\n  'purple',\n  'teal',\n  'gray',\n  'gray',\n  'red',\n  'red',\n  'red'\n];\n","import {DEFAULT_COLOR_SCHEME} from '../resources/color-schemes';\nimport {NgxLoggerLevel} from '../types/logger-level.enum';\n\nexport class NGXLoggerUtils {\n\n  static prepareMetaString(timestamp: string, logLevel: string, fileName: string, lineNumber: string) {\n    const fileDetails = fileName ? ` [${fileName}:${lineNumber}]` : '';\n\n    return `${timestamp} ${logLevel}${fileDetails}`;\n  }\n\n  static getColor(level: NgxLoggerLevel, configColorScheme?: Array<string>): string | undefined {\n    switch (level) {\n      case NgxLoggerLevel.TRACE:\n        return this.getColorFromConfig(NgxLoggerLevel.TRACE, configColorScheme);\n      case NgxLoggerLevel.DEBUG:\n        return this.getColorFromConfig(NgxLoggerLevel.DEBUG, configColorScheme);\n      case NgxLoggerLevel.INFO:\n        return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);\n      case NgxLoggerLevel.LOG:\n        return this.getColorFromConfig(NgxLoggerLevel.INFO, configColorScheme);\n      case NgxLoggerLevel.WARN:\n        return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);\n      case NgxLoggerLevel.ERROR:\n        return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);\n      case NgxLoggerLevel.FATAL:\n        return this.getColorFromConfig(NgxLoggerLevel.FATAL, configColorScheme);\n      case NgxLoggerLevel.OFF:\n      default:\n        return;\n    }\n  }\n\n  private static getColorFromConfig(level: number, configColorScheme: Array<string>): string | undefined {\n    if (!configColorScheme) {\n      return DEFAULT_COLOR_SCHEME[level];\n    }\n\n    return configColorScheme[level];\n  }\n\n  /**\n   *  This allows us to see who called the logger\n   */\n  static getCallerDetails(): { lineNumber: string, fileName: string } {\n    const err = (new Error(''));\n\n    try {\n      // this should produce the line which NGX Logger was called\n      const callerLine = err.stack.split('\\n')[4].split('/');\n\n      // returns the file:lineNumber\n      const fileLineNumber = callerLine[callerLine.length - 1].replace(/[)]/g, '').split(':');\n\n      return {\n        fileName: fileLineNumber[0],\n        lineNumber: fileLineNumber[1]\n      };\n    } catch (e) {\n      return {\n        fileName: null,\n        lineNumber: null\n      };\n    }\n\n  }\n\n  static prepareMessage(message) {\n    try {\n      if (typeof message !== 'string' && !(message instanceof Error)) {\n        message = JSON.stringify(message, null, 2);\n      }\n    } catch (e) {\n      // additional = [message, ...additional];\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\n    }\n\n    return message;\n  }\n\n  static prepareAdditionalParameters(additional: any[]) {\n    if (additional === null || additional === undefined) {\n      return null;\n    }\n\n    return additional.map((next, idx) => {\n      try {\n        // We just want to make sure the JSON can be parsed, we do not want to actually change the type\n        if (typeof next === 'object') {\n          JSON.stringify(next);\n        }\n\n        return next;\n      } catch (e) {\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\n      }\n    });\n  }\n\n}\n","export class LogPosition {\n  constructor(\n    public fileName: string,\n    public lineNumber: number,\n    public columnNumber: number\n  ) {}\n  toString() {\n    return this.fileName + ':' + this.lineNumber + ':' + this.columnNumber;\n  }\n}\n","import {SourceMap} from '@angular/compiler';\nimport {Injectable} from '@angular/core';\nimport {HttpBackend, HttpRequest, HttpResponse} from '@angular/common/http';\nimport * as vlq from 'vlq';\nimport {Observable, of} from 'rxjs';\nimport {catchError, filter, map, retry, shareReplay, switchMap} from 'rxjs/operators';\nimport {LogPosition} from './types/log-position';\n\n@Injectable()\nexport class NGXMapperService {\n\n  // cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map'\n  private sourceMapCache: Map<string, Observable<SourceMap>> = new Map();\n\n  // cache for specific log position, key is the dist position, ie 'main.js:339:21'\n  private logPositionCache: Map<string, Observable<LogPosition>> = new Map();\n\n  constructor(private httpBackend: HttpBackend) {\n  }\n\n  /*\n  Static Functions\n */\n  private static getStackLine(): string {\n    const error = new Error();\n\n    try {\n      // noinspection ExceptionCaughtLocallyJS\n      throw error;\n    } catch (e) {\n\n      try {\n        return error.stack.split('\\n')[5];\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n\n  private static getPosition(stackLine: string): LogPosition {\n    // strip base path, then parse filename, line, and column\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\n    let positionEndIndex = stackLine.indexOf(')');\n    if (positionEndIndex < 0) {\n      positionEndIndex = undefined;\n    }\n\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\n    const dataArray = position.split(':');\n    if (dataArray.length === 3) {\n      return new LogPosition(dataArray[0], +dataArray[1], +dataArray[2]);\n    }\n    return new LogPosition('unknown', 0, 0);\n  }\n\n  private static getTranspileLocation(stackLine: string): string {\n    let locationStartIndex = stackLine.indexOf('(');\n    if (locationStartIndex < 0) {\n      locationStartIndex = stackLine.lastIndexOf(' ');\n    }\n\n    let locationEndIndex = stackLine.indexOf(')');\n    if (locationEndIndex < 0) {\n      locationEndIndex = undefined;\n    }\n\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\n  }\n\n  private static getMapFilePath(stackLine: string): string {\n    const file = NGXMapperService.getTranspileLocation(stackLine);\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\n  }\n\n  private static getMapping(sourceMap: SourceMap, position: LogPosition): LogPosition {\n    // => ';' indicates end of a line\n    // => ',' separates mappings in a line\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\n    let sourceFileIndex = 0,   // second field\n      sourceCodeLine = 0,    // third field\n      sourceCodeColumn = 0;  // fourth field\n\n    const lines = sourceMap.mappings.split(';');\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      // reset column position to 0 after each line\n      let generatedCodeColumn = 0;\n      // decode sections in line\n      const columns = lines[lineIndex].split(',');\n\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n        const decodedSection = vlq.decode(columns[columnIndex]);\n        if (decodedSection.length >= 4) {\n          // update relative positions\n          generatedCodeColumn += decodedSection[0];\n          sourceFileIndex += decodedSection[1];\n          sourceCodeLine += decodedSection[2];\n          sourceCodeColumn += decodedSection[3];\n        }\n\n        // check if matching map\n        if (lineIndex === position.lineNumber) {\n          if (generatedCodeColumn === position.columnNumber) {\n            // matching column and line found\n            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, sourceCodeColumn);\n          } else if (columnIndex + 1 === columns.length) {\n            // matching column not found, but line is correct\n            return new LogPosition(sourceMap.sources[sourceFileIndex], sourceCodeLine, 0);\n          }\n        }\n      }\n    }\n    // failed if reached\n    return new LogPosition('unknown', 0, 0);\n  }\n\n  /**\n   * does the http get request to get the source map\n   * @param sourceMapLocation\n   * @param distPosition\n   */\n  private _getSourceMap(sourceMapLocation: string, distPosition: LogPosition): Observable<LogPosition> {\n    const req = new HttpRequest<SourceMap>('GET', sourceMapLocation);\n    const distPositionKey = distPosition.toString();\n\n    // if the specific log position is already in cache return it\n    if (this.logPositionCache.has(distPositionKey)) {\n      return this.logPositionCache.get(distPositionKey);\n    }\n\n    // otherwise check if the source map is already cached for given source map location\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\n      // obtain the source map if not cached\n      this.sourceMapCache.set(\n        sourceMapLocation,\n        this.httpBackend.handle(req).pipe(\n          filter((e) => e instanceof HttpResponse),\n          map<HttpResponse<SourceMap>, SourceMap>(\n            (httpResponse: HttpResponse<SourceMap>) => httpResponse.body\n          ),\n          retry(3),\n          shareReplay(1)\n        )\n      );\n    }\n\n    // at this point the source map is cached, use it to get specific log position mapping\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(\n      map<SourceMap, LogPosition>((sourceMap) =>\n        // map generated position to source position\n        NGXMapperService.getMapping(sourceMap, distPosition)\n      ),\n      catchError(() => of(distPosition)),\n      shareReplay(1)\n    );\n\n    // store specific log position in cache for given dest position and return it\n    this.logPositionCache.set(distPositionKey, logPosition$);\n\n    return logPosition$;\n  }\n\n  /**\n   * Returns the LogPosition for the current log\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the file name\n   * and number of the call\n   * @param sourceMapsEnabled\n   */\n  public getCallerDetails(sourceMapsEnabled: boolean): Observable<LogPosition> {\n    // parse generated file mapping from stack trace\n\n    const stackLine = NGXMapperService.getStackLine();\n\n    // if we were not able to parse the stackLine, just return an empty Log Position\n    if (!stackLine) {\n      return of(new LogPosition('', 0, 0));\n    }\n\n    return of([\n      NGXMapperService.getPosition(stackLine),\n      NGXMapperService.getMapFilePath(stackLine)\n    ]).pipe(\n      switchMap<[LogPosition, string], Observable<LogPosition>>(([distPosition, sourceMapLocation]) => {\n\n        // if source maps are not enabled, or if we've previously tried to get the source maps, but they failed,\n        // then just use the position of the JS instead of the source\n        if (!sourceMapsEnabled) {\n          return of(distPosition);\n        }\n\n        // finally try to get the source map and return the position\n        return this._getSourceMap(sourceMapLocation, distPosition);\n      })\n    );\n\n\n  }\n}\n\n\n\n\n","import { Inject, Injectable, PLATFORM_ID } from '@angular/core';\nimport { HttpErrorResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { isPlatformBrowser, DatePipe } from '@angular/common';\n\nimport { NGXLoggerHttpService } from './http.service';\nimport { LogPosition } from './types/log-position';\nimport { NgxLoggerLevel } from './types/logger-level.enum';\nimport { LoggerConfig } from './logger.config';\nimport { NGXLoggerConfigEngine } from './config.engine';\nimport { NGXLoggerUtils } from './utils/logger.utils';\nimport { NGXLoggerMonitor } from './logger-monitor';\nimport { NGXLogInterface } from './types/ngx-log.interface';\nimport { NGXMapperService } from './mapper.service';\n\nexport const Levels = [\n  'TRACE',\n  'DEBUG',\n  'INFO',\n  'LOG',\n  'WARN',\n  'ERROR',\n  'FATAL',\n  'OFF'\n];\n\n\n@Injectable()\nexport class NGXLogger {\n  private readonly _isIE: boolean;\n  private readonly _logFunc: Function;\n  private config: NGXLoggerConfigEngine;\n  private _customHttpHeaders: HttpHeaders;\n  private _customParams: HttpParams;\n  private _withCredentials: boolean = false;\n\n  private _loggerMonitor: NGXLoggerMonitor;\n\n  constructor(private readonly mapperService: NGXMapperService, private readonly httpService: NGXLoggerHttpService,\n    loggerConfig: LoggerConfig, @Inject(PLATFORM_ID) private platformId,\n    private readonly datePipe: DatePipe) {\n    this._isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\n      !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\n\n    // each instance of the logger should have their own config engine\n    this.config = new NGXLoggerConfigEngine(loggerConfig);\n\n    this._logFunc = this._isIE ? this._logIE.bind(this) : this._logModern.bind(this);\n\n  }\n\n  public trace(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.TRACE, message, additional);\n  }\n\n  public debug(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\n  }\n\n  public info(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.INFO, message, additional);\n  }\n\n  public log(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.LOG, message, additional);\n  }\n\n  public warn(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.WARN, message, additional);\n  }\n\n  public error(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.ERROR, message, additional);\n  }\n\n  public fatal(message, ...additional: any[]): void {\n    this._log(NgxLoggerLevel.FATAL, message, additional);\n  }\n\n  public setCustomHttpHeaders(headers: HttpHeaders) {\n    this._customHttpHeaders = headers;\n  }\n\n  public setCustomParams(params: HttpParams) {\n    this._customParams = params;\n  }\n\n  public setWithCredentialsOptionValue(withCredentials: boolean) {\n    this._withCredentials = withCredentials;\n  }\n\n  public registerMonitor(monitor: NGXLoggerMonitor) {\n    this._loggerMonitor = monitor;\n  }\n\n  public updateConfig(config: LoggerConfig) {\n    this.config.updateConfig(config);\n  }\n\n  public getConfigSnapshot(): LoggerConfig {\n    return this.config.getConfig();\n  }\n\n  private _logIE(level: NgxLoggerLevel, metaString: string, message: string, additional: any[]): void {\n\n    // Coloring doesn't work in IE\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    additional = additional || [];\n\n    switch (level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`${metaString} `, message, ...additional);\n        break;\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`${metaString} `, message, ...additional);\n        break;\n      case NgxLoggerLevel.INFO:\n        console.info(`${metaString} `, message, ...additional);\n        break;\n      default:\n        console.log(`${metaString} `, message, ...additional);\n    }\n  }\n\n  private _logModern(level: NgxLoggerLevel, metaString: string, message: string, additional: any[]): void {\n    const configuredColors = this.getConfigSnapshot().colorScheme;\n    const color = NGXLoggerUtils.getColor(level, configuredColors);\n\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    additional = additional || [];\n\n    switch (level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`%c${metaString}`, `color:${color}`, message, ...additional);\n        break;\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`%c${metaString}`, `color:${color}`, message, ...additional);\n        break;\n      case NgxLoggerLevel.INFO:\n        console.info(`%c${metaString}`, `color:${color}`, message, ...additional);\n        break;\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\n      // the console.trace statement\n      // case NgxLoggerLevel.TRACE:\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\n      //   break;\n\n      //  Disabling console.debug, because Has this hidden by default.\n      // case NgxLoggerLevel.DEBUG:\n      //   console.debug(`%c${metaString}`, `color:${color}`, message, ...additional);\n      //   break;\n      default:\n        console.log(`%c${metaString}`, `color:${color}`, message, ...additional);\n    }\n  }\n\n  private _log(level: NgxLoggerLevel, message, additional: any[] = [], logOnServer: boolean = true): void {\n    const config = this.config.getConfig();\n    const isLog2Server = logOnServer && config.serverLoggingUrl && level >= config.serverLogLevel;\n    const isLogLevelEnabled = level >= config.level;\n\n    if (!(message && (isLog2Server || isLogLevelEnabled))) {\n      return;\n    }\n\n    const logLevelString = Levels[level];\n\n    message = typeof message === 'function' ? message() : message;\n    message = NGXLoggerUtils.prepareMessage(message);\n\n    // only use validated parameters for HTTP requests\n    const validatedAdditionalParameters = NGXLoggerUtils.prepareAdditionalParameters(additional);\n\n    const timestamp = config.timestampFormat ?\n      this.datePipe.transform(new Date(), config.timestampFormat) :\n      new Date().toISOString();\n\n    // const callerDetails = NGXLoggerUtils.getCallerDetails();\n    this.mapperService.getCallerDetails(config.enableSourceMaps).subscribe((callerDetails: LogPosition) => {\n      const logObject: NGXLogInterface = {\n        message: message,\n        additional: validatedAdditionalParameters,\n        level: level,\n        timestamp: timestamp,\n        fileName: callerDetails.fileName,\n        lineNumber: callerDetails.lineNumber.toString()\n      };\n\n      if (this._loggerMonitor && isLogLevelEnabled) {\n        this._loggerMonitor.onLog(logObject);\n      }\n\n      if (isLog2Server) {\n        // make sure the stack gets sent to the server\n        message = message instanceof Error ? message.stack : message;\n        logObject.message = message;\n\n        const headers = this._customHttpHeaders || new HttpHeaders();\n        headers.set('Content-Type', 'application/json');\n\n        const options = {\n          headers: headers,\n          params: this._customParams || new HttpParams(),\n          responseType: config.httpResponseType || 'json',\n          withCredentials: this._withCredentials\n        };\n        // Allow logging on server even if client log level is off\n        this.httpService.logOnServer(config.serverLoggingUrl, logObject, options).subscribe((res: any) => {\n          // I don't think we should do anything on success\n        },\n          (error: HttpErrorResponse) => {\n            this._log(NgxLoggerLevel.ERROR, `FAILED TO LOG ON SERVER: ${message}`, [error], false);\n          }\n        );\n      }\n\n\n      // if no message or the log level is less than the environ\n      if (isLogLevelEnabled && !config.disableConsoleLogging) {\n        const metaString = NGXLoggerUtils.prepareMetaString(timestamp, logLevelString,\n          callerDetails.fileName, callerDetails.lineNumber.toString());\n\n        return this._logFunc(level, metaString, message, additional);\n      }\n    });\n  }\n}\n","import {Inject, Injectable, PLATFORM_ID} from '@angular/core';\nimport { DatePipe } from '@angular/common';\n\nimport {LoggerConfig} from './logger.config';\nimport {NGXLoggerHttpService} from './http.service';\nimport {NGXLogger} from './logger.service';\nimport {NGXLoggerMonitor} from './logger-monitor';\nimport {NGXMapperService} from './mapper.service';\n\n\n/**\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\n */\n@Injectable()\nexport class CustomNGXLoggerService {\n\n  constructor(private readonly mapperService: NGXMapperService,\n              private readonly httpService: NGXLoggerHttpService,\n              @Inject(PLATFORM_ID) private readonly platformId, private readonly datePipe: DatePipe) {\n  }\n\n  create(config: LoggerConfig, httpService?: NGXLoggerHttpService, logMonitor?: NGXLoggerMonitor,\n         mapperService?: NGXMapperService): NGXLogger {\n    // you can inject your own httpService or use the default,\n    const logger = new NGXLogger(mapperService || this.mapperService,\n      httpService || this.httpService, config, this.platformId, this.datePipe);\n\n    if (logMonitor) {\n      logger.registerMonitor(logMonitor);\n    }\n\n    return logger;\n  }\n}\n\n\n","import {CommonModule, DatePipe} from '@angular/common';\nimport {ModuleWithProviders, NgModule} from '@angular/core';\n\nimport {NGXLogger} from './logger.service';\nimport {LoggerConfig} from './logger.config';\nimport {CustomNGXLoggerService} from './custom-logger.service';\nimport {NGXLoggerHttpService} from './http.service';\nimport {NGXMapperService} from './mapper.service';\n\n@NgModule({\n  imports: [\n    CommonModule\n  ],\n  providers: [\n    NGXLogger,\n    NGXLoggerHttpService,\n    CustomNGXLoggerService,\n    NGXMapperService,\n    DatePipe\n  ]\n})\nexport class LoggerModule {\n  static forRoot(config: LoggerConfig | null | undefined): ModuleWithProviders<LoggerModule> {\n    return {\n      ngModule: LoggerModule,\n      providers: [\n        {provide: LoggerConfig, useValue: config || {}},\n        NGXLogger,\n        NGXLoggerHttpService,\n        CustomNGXLoggerService,\n        NGXMapperService\n      ]\n    };\n  }\n  static forChild(): ModuleWithProviders<LoggerModule> {\n    return {\n      ngModule: LoggerModule,\n      providers: [\n        NGXLogger,\n        NGXLoggerHttpService,\n        CustomNGXLoggerService,\n        NGXMapperService\n      ]\n    };\n  }\n}\n","import {NGXLogInterface} from './types/ngx-log.interface';\n\nexport abstract class NGXLoggerMonitor {\n  abstract onLog(logObject: NGXLogInterface): void;\n}\n","import {NgxLoggerLevel} from './logger-level.enum';\n\nexport class NGXLogInterface {\n  level: NgxLoggerLevel;\n  timestamp: string;\n  fileName: string;\n  lineNumber: string;\n  message: string;\n  additional: any[];\n}\n"],"names":["vlq.decode"],"mappings":"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"}